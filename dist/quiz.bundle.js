/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/SCORM_API_wrapper.js":
/*!*************************************!*\
  !*** ./src/js/SCORM_API_wrapper.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pipwerks: () => (/* binding */ pipwerks)\n/* harmony export */ });\n/* =====================================================================================\r\n\r\nSCORM wrapper v1.1.7 by Philip Hutchison, May 2008 (http://pipwerks.com).\r\n\r\nCopyright (c) 2008 Philip Hutchison\r\nMIT-style license. Full license text can be found at \r\nhttp://www.opensource.org/licenses/mit-license.php\r\n\r\nThis wrapper is designed to work with both SCORM 1.2 and SCORM 2004.\r\n\r\nBased on APIWrapper.js, created by the ADL and Concurrent Technologies\r\nCorporation, distributed by the ADL (http://www.adlnet.gov/scorm).\r\n\r\nSCORM.API.find() and SCORM.API.get() functions based on ADL code,\r\nmodified by Mike Rustici (http://www.scorm.com/resources/apifinder/SCORMAPIFinder.htm),\r\nfurther modified by Philip Hutchison\r\n\r\n======================================================================================== */\n\nvar pipwerks = {}; //pipwerks 'namespace' helps ensure no conflicts with possible other \"SCORM\" variables\npipwerks.UTILS = {}; //For holding UTILS functions\npipwerks.debug = {\n  isActive: true\n}; //Enable (true) or disable (false) for debug mode\n\npipwerks.SCORM = {\n  //Define the SCORM object\n  version: null,\n  //Store SCORM version.\n  handleCompletionStatus: true,\n  //Whether or not the wrapper should automatically handle the initial completion status\n  handleExitMode: true,\n  //Whether or not the wrapper should automatically handle the exit mode\n  API: {\n    handle: null,\n    isFound: false\n  },\n  //Create API child object\n  connection: {\n    isActive: false\n  },\n  //Create connection child object\n  data: {\n    completionStatus: null,\n    exitStatus: null\n  },\n  //Create data child object\n  debug: {} //Create debug child object\n};\n\n/* --------------------------------------------------------------------------------\r\n   pipwerks.SCORM.isAvailable\r\n   A simple function to allow Flash ExternalInterface to confirm \r\n   presence of JS wrapper before attempting any LMS communication.\r\n\r\n   Parameters: none\r\n   Returns:    Boolean (true)\r\n----------------------------------------------------------------------------------- */\n\npipwerks.SCORM.isAvailable = function () {\n  return true;\n};\n\n// ------------------------------------------------------------------------- //\n// --- SCORM.API functions ------------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.API.find(window)\r\n   Looks for an object named API in parent and opener windows\r\n   \r\n   Parameters: window (the browser window object).\r\n   Returns:    Object if API is found, null if no API found\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.find = function (win) {\n  var API = null,\n    findAttempts = 0,\n    findAttemptLimit = 500,\n    traceMsgPrefix = \"SCORM.API.find\",\n    trace = pipwerks.UTILS.trace,\n    scorm = pipwerks.SCORM;\n  while (!win.API && !win.API_1484_11 && win.parent && win.parent != win && findAttempts <= findAttemptLimit) {\n    findAttempts++;\n    win = win.parent;\n  }\n  if (scorm.version) {\n    //If SCORM version is specified by user, look for specific API\n\n    switch (scorm.version) {\n      case \"2004\":\n        if (win.API_1484_11) {\n          API = win.API_1484_11;\n        } else {\n          trace(traceMsgPrefix + \": SCORM version 2004 was specified by user, but API_1484_11 cannot be found.\");\n        }\n        break;\n      case \"1.2\":\n        if (win.API) {\n          API = win.API;\n        } else {\n          trace(traceMsgPrefix + \": SCORM version 1.2 was specified by user, but API cannot be found.\");\n        }\n        break;\n    }\n  } else {\n    //If SCORM version not specified by user, look for APIs\n\n    if (win.API_1484_11) {\n      //SCORM 2004-specific API.\n\n      scorm.version = \"2004\"; //Set version\n      API = win.API_1484_11;\n    } else if (win.API) {\n      //SCORM 1.2-specific API\n\n      scorm.version = \"1.2\"; //Set version\n      API = win.API;\n    }\n  }\n  if (API) {\n    trace(traceMsgPrefix + \": API found. Version: \" + scorm.version);\n    trace(\"API: \" + API);\n  } else {\n    trace(traceMsgPrefix + \": Error finding API. \\nFind attempts: \" + findAttempts + \". \\nFind attempt limit: \" + findAttemptLimit);\n  }\n  return API;\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.API.get()\r\n   Looks for an object named API, first in the current window's frame\r\n   hierarchy and then, if necessary, in the current window's opener window\r\n   hierarchy (if there is an opener window).\r\n\r\n   Parameters:  None. \r\n   Returns:     Object if API found, null if no API found\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.get = function () {\n  var API = null,\n    win = window,\n    find = pipwerks.SCORM.API.find,\n    trace = pipwerks.UTILS.trace;\n  if (win.parent && win.parent != win) {\n    API = find(win.parent);\n  }\n  if (!API && win.top.opener) {\n    API = find(win.top.opener);\n  }\n  if (API) {\n    pipwerks.SCORM.API.isFound = true;\n  } else {\n    trace(\"API.get failed: Can't find the API!\");\n  }\n  return API;\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.API.getHandle()\r\n   Returns the handle to API object if it was previously set\r\n\r\n   Parameters:  None.\r\n   Returns:     Object (the pipwerks.SCORM.API.handle variable).\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.API.getHandle = function () {\n  var API = pipwerks.SCORM.API;\n  if (!API.handle && !API.isFound) {\n    API.handle = API.get();\n  }\n  return API.handle;\n};\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.connection functions --------------------------------- //\n// ------------------------------------------------------------------------- //\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.connection.initialize()\r\n   Tells the LMS to initiate the communication session.\r\n\r\n   Parameters:  None\r\n   Returns:     Boolean\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.connection.initialize = function () {\n  var success = false,\n    scorm = pipwerks.SCORM,\n    completionStatus = pipwerks.SCORM.data.completionStatus,\n    trace = pipwerks.UTILS.trace,\n    makeBoolean = pipwerks.UTILS.StringToBoolean,\n    debug = pipwerks.SCORM.debug,\n    traceMsgPrefix = \"SCORM.connection.initialize \";\n  trace(\"connection.initialize called.\");\n  if (!scorm.connection.isActive) {\n    var API = scorm.API.getHandle(),\n      errorCode = 0;\n    if (API) {\n      switch (scorm.version) {\n        case \"1.2\":\n          success = makeBoolean(API.LMSInitialize(\"\"));\n          break;\n        case \"2004\":\n          success = makeBoolean(API.Initialize(\"\"));\n          break;\n      }\n      if (success) {\n        //Double-check that connection is active and working before returning 'true' boolean\n        errorCode = debug.getCode();\n        if (errorCode !== null && errorCode === 0) {\n          scorm.connection.isActive = true;\n          if (scorm.handleCompletionStatus) {\n            //Automatically set new launches to incomplete \n            completionStatus = pipwerks.SCORM.status(\"get\");\n            if (completionStatus) {\n              switch (completionStatus) {\n                //Both SCORM 1.2 and 2004\n                case \"not attempted\":\n                  pipwerks.SCORM.status(\"set\", \"incomplete\");\n                  break;\n\n                //SCORM 2004 only\n                case \"unknown\":\n                  pipwerks.SCORM.status(\"set\", \"incomplete\");\n                  break;\n\n                //Additional options, presented here in case you'd like to use them\n                //case \"completed\"  : break;\n                //case \"incomplete\" : break;\n                //case \"passed\"     : break;\t//SCORM 1.2 only\n                //case \"failed\"     : break;\t//SCORM 1.2 only\n                //case \"browsed\"    : break;\t//SCORM 1.2 only\n              }\n            }\n          }\n        } else {\n          success = false;\n          trace(traceMsgPrefix + \"failed. \\nError code: \" + errorCode + \" \\nError info: \" + debug.getInfo(errorCode));\n        }\n      } else {\n        errorCode = debug.getCode();\n        if (errorCode !== null && errorCode !== 0) {\n          trace(traceMsgPrefix + \"failed. \\nError code: \" + errorCode + \" \\nError info: \" + debug.getInfo(errorCode));\n        } else {\n          trace(traceMsgPrefix + \"failed: No response from server.\");\n        }\n      }\n    } else {\n      trace(traceMsgPrefix + \"failed: API is null.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \"aborted: Connection already active.\");\n  }\n  return success;\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.connection.terminate()\r\n   Tells the LMS to terminate the communication session\r\n\r\n   Parameters:  None\r\n   Returns:     Boolean\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.connection.terminate = function () {\n  var success = false,\n    scorm = pipwerks.SCORM,\n    exitStatus = pipwerks.SCORM.data.exitStatus,\n    completionStatus = pipwerks.SCORM.data.completionStatus,\n    trace = pipwerks.UTILS.trace,\n    makeBoolean = pipwerks.UTILS.StringToBoolean,\n    debug = pipwerks.SCORM.debug,\n    traceMsgPrefix = \"SCORM.connection.terminate \";\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle(),\n      errorCode = 0;\n    if (API) {\n      if (scorm.handleExitMode && !exitStatus) {\n        if (completionStatus !== \"completed\" && completionStatus !== \"passed\") {\n          switch (scorm.version) {\n            case \"1.2\":\n              success = scorm.set(\"cmi.core.exit\", \"suspend\");\n              break;\n            case \"2004\":\n              success = scorm.set(\"cmi.exit\", \"suspend\");\n              break;\n          }\n        } else {\n          switch (scorm.version) {\n            case \"1.2\":\n              success = scorm.set(\"cmi.core.exit\", \"logout\");\n              break;\n            case \"2004\":\n              success = scorm.set(\"cmi.exit\", \"normal\");\n              break;\n          }\n        }\n      }\n      switch (scorm.version) {\n        case \"1.2\":\n          success = makeBoolean(API.LMSFinish(\"\"));\n          break;\n        case \"2004\":\n          success = makeBoolean(API.Terminate(\"\"));\n          break;\n      }\n      if (success) {\n        scorm.connection.isActive = false;\n      } else {\n        errorCode = debug.getCode();\n        trace(traceMsgPrefix + \"failed. \\nError code: \" + errorCode + \" \\nError info: \" + debug.getInfo(errorCode));\n      }\n    } else {\n      trace(traceMsgPrefix + \"failed: API is null.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \"aborted: Connection already terminated.\");\n  }\n  return success;\n};\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.data functions --------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.data.get(parameter)\r\n   Requests information from the LMS.\r\n\r\n   Parameter: parameter (string, name of the SCORM data model element)\r\n   Returns:   string (the value of the specified data model element)\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.get = function (parameter) {\n  var value = null,\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    debug = pipwerks.SCORM.debug,\n    traceMsgPrefix = \"SCORM.data.get(\" + parameter + \") \";\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle(),\n      errorCode = 0;\n    if (API) {\n      switch (scorm.version) {\n        case \"1.2\":\n          value = API.LMSGetValue(parameter);\n          break;\n        case \"2004\":\n          value = API.GetValue(parameter);\n          break;\n      }\n      errorCode = debug.getCode();\n\n      //GetValue returns an empty string on errors\n      //Double-check errorCode to make sure empty string\n      //is really an error and not field value\n      if (value !== \"\" && errorCode === 0) {\n        switch (parameter) {\n          case \"cmi.core.lesson_status\":\n          case \"cmi.completion_status\":\n            scorm.data.completionStatus = value;\n            break;\n          case \"cmi.core.exit\":\n          case \"cmi.exit\":\n            scorm.data.exitStatus = value;\n            break;\n        }\n      } else {\n        trace(traceMsgPrefix + \"failed. \\nError code: \" + errorCode + \"\\nError info: \" + debug.getInfo(errorCode));\n      }\n    } else {\n      trace(traceMsgPrefix + \"failed: API is null.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \"failed: API connection is inactive.\");\n  }\n  trace(traceMsgPrefix + \" value: \" + value);\n  return String(value);\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.data.set()\r\n   Tells the LMS to assign the value to the named data model element.\r\n   Also stores the SCO's completion status in a variable named\r\n   pipwerks.SCORM.data.completionStatus. This variable is checked whenever\r\n   pipwerks.SCORM.connection.terminate() is invoked.\r\n\r\n   Parameters: parameter (string). The data model element\r\n               value (string). The value for the data model element\r\n   Returns:    Boolean\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.set = function (parameter, value) {\n  var success = false,\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    makeBoolean = pipwerks.UTILS.StringToBoolean,\n    debug = pipwerks.SCORM.debug,\n    traceMsgPrefix = \"SCORM.data.set(\" + parameter + \") \";\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle(),\n      errorCode = 0;\n    if (API) {\n      switch (scorm.version) {\n        case \"1.2\":\n          success = makeBoolean(API.LMSSetValue(parameter, value));\n          break;\n        case \"2004\":\n          success = makeBoolean(API.SetValue(parameter, value));\n          break;\n      }\n      if (success) {\n        if (parameter === \"cmi.core.lesson_status\" || parameter === \"cmi.completion_status\") {\n          scorm.data.completionStatus = value;\n        }\n      } else {\n        trace(traceMsgPrefix + \"failed. \\nError code: \" + errorCode + \". \\nError info: \" + debug.getInfo(errorCode));\n      }\n    } else {\n      trace(traceMsgPrefix + \"failed: API is null.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \"failed: API connection is inactive.\");\n  }\n  return success;\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.data.save()\r\n   Instructs the LMS to persist all data to this point in the session\r\n\r\n   Parameters: None\r\n   Returns:    Boolean\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.data.save = function () {\n  var success = false,\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    makeBoolean = pipwerks.UTILS.StringToBoolean,\n    traceMsgPrefix = \"SCORM.data.save failed\";\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle();\n    if (API) {\n      switch (scorm.version) {\n        case \"1.2\":\n          success = makeBoolean(API.LMSCommit(\"\"));\n          break;\n        case \"2004\":\n          success = makeBoolean(API.Commit(\"\"));\n          break;\n      }\n    } else {\n      trace(traceMsgPrefix + \": API is null.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \": API connection is inactive.\");\n  }\n  return success;\n};\npipwerks.SCORM.status = function (action, status) {\n  var success = false,\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    traceMsgPrefix = \"SCORM.getStatus failed\",\n    cmi = \"\";\n  if (action !== null) {\n    switch (scorm.version) {\n      case \"1.2\":\n        cmi = \"cmi.core.lesson_status\";\n        break;\n      case \"2004\":\n        cmi = \"cmi.completion_status\";\n        break;\n    }\n    switch (action) {\n      case \"get\":\n        success = pipwerks.SCORM.data.get(cmi);\n        break;\n      case \"set\":\n        if (status !== null) {\n          success = pipwerks.SCORM.data.set(cmi, status);\n        } else {\n          success = false;\n          trace(traceMsgPrefix + \": status was not specified.\");\n        }\n        break;\n      default:\n        success = false;\n        trace(traceMsgPrefix + \": no valid action was specified.\");\n    }\n  } else {\n    trace(traceMsgPrefix + \": action was not specified.\");\n  }\n  return success;\n};\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.SCORM.debug functions -------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.debug.getCode\r\n   Requests the error code for the current error state from the LMS\r\n\r\n   Parameters: None\r\n   Returns:    Integer (the last error code).\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getCode = function () {\n  var API = pipwerks.SCORM.API.getHandle(),\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    code = 0;\n  if (API) {\n    switch (scorm.version) {\n      case \"1.2\":\n        code = parseInt(API.LMSGetLastError(), 10);\n        break;\n      case \"2004\":\n        code = parseInt(API.GetLastError(), 10);\n        break;\n    }\n  } else {\n    trace(\"SCORM.debug.getCode failed: API is null.\");\n  }\n  return code;\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.debug.getInfo()\r\n   \"Used by a SCO to request the textual description for the error code\r\n   specified by the value of [errorCode].\"\r\n\r\n   Parameters: errorCode (integer).  \r\n   Returns:    String.\r\n----------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getInfo = function (errorCode) {\n  var API = pipwerks.SCORM.API.getHandle(),\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    result = \"\";\n  if (API) {\n    switch (scorm.version) {\n      case \"1.2\":\n        result = API.LMSGetErrorString(errorCode.toString());\n        break;\n      case \"2004\":\n        result = API.GetErrorString(errorCode.toString());\n        break;\n    }\n  } else {\n    trace(\"SCORM.debug.getInfo failed: API is null.\");\n  }\n  return String(result);\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.SCORM.debug.getDiagnosticInfo\r\n   \"Exists for LMS specific use. It allows the LMS to define additional\r\n   diagnostic information through the API Instance.\"\r\n\r\n   Parameters: errorCode (integer).  \r\n   Returns:    String (Additional diagnostic information about the given error code).\r\n---------------------------------------------------------------------------- */\n\npipwerks.SCORM.debug.getDiagnosticInfo = function (errorCode) {\n  var API = pipwerks.SCORM.API.getHandle(),\n    scorm = pipwerks.SCORM,\n    trace = pipwerks.UTILS.trace,\n    result = \"\";\n  if (API) {\n    switch (scorm.version) {\n      case \"1.2\":\n        result = API.LMSGetDiagnostic(errorCode);\n        break;\n      case \"2004\":\n        result = API.GetDiagnostic(errorCode);\n        break;\n    }\n  } else {\n    trace(\"SCORM.debug.getDiagnosticInfo failed: API is null.\");\n  }\n  return String(result);\n};\n\n// ------------------------------------------------------------------------- //\n// --- Shortcuts! ---------------------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n// Because nobody likes typing verbose code.\n\npipwerks.SCORM.init = pipwerks.SCORM.connection.initialize;\npipwerks.SCORM.get = pipwerks.SCORM.data.get;\npipwerks.SCORM.set = pipwerks.SCORM.data.set;\npipwerks.SCORM.save = pipwerks.SCORM.data.save;\npipwerks.SCORM.quit = pipwerks.SCORM.connection.terminate;\n\n// ------------------------------------------------------------------------- //\n// --- pipwerks.UTILS functions -------------------------------------------- //\n// ------------------------------------------------------------------------- //\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.UTILS.StringToBoolean()\r\n   Converts 'boolean strings' into actual valid booleans.\r\n   \r\n   (Most values returned from the API are the strings \"true\" and \"false\".)\r\n\r\n   Parameters: String\r\n   Returns:    Boolean\r\n---------------------------------------------------------------------------- */\n\npipwerks.UTILS.StringToBoolean = function (string) {\n  switch (string.toLowerCase()) {\n    case \"true\":\n    case \"yes\":\n    case \"1\":\n      return true;\n    case \"false\":\n    case \"no\":\n    case \"0\":\n    case null:\n      return false;\n    default:\n      return Boolean(string);\n  }\n};\n\n/* -------------------------------------------------------------------------\r\n   pipwerks.UTILS.trace()\r\n   Displays error messages when in debug mode.\r\n\r\n   Parameters: msg (string)  \r\n   Return:     None\r\n---------------------------------------------------------------------------- */\n\npipwerks.UTILS.trace = function (msg) {\n  if (pipwerks.debug.isActive) {\n    //Firefox users can use the 'Firebug' extension's console.\n    if (window.console && window.console.firebug) {\n      console.log(msg);\n    } else {\n      //alert(msg);\n    }\n  }\n};\n\n//# sourceURL=webpack://MyLibrary/./src/js/SCORM_API_wrapper.js?");

/***/ }),

/***/ "./src/js/class2.js":
/*!**************************!*\
  !*** ./src/js/class2.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cercle: () => (/* binding */ Cercle),\n/* harmony export */   Droite: () => (/* binding */ Droite),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Vecteur: () => (/* binding */ Vecteur)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nclass Point {\n  constructor(_x, _y) {\n    _defineProperty(this, \"setCoordonneesPoint\", function (point, x, y) {\n      point.x = x;\n      point.y = y;\n    });\n    _defineProperty(this, \"getCoordonneesPoint\", function (point) {\n      return [point.x, point.y];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Point(this.x + vecteur.x, this.y + vecteur.y);\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (point) {\n      return new Point(2 * point.x - this.x, 2 * point.y - this.y);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (point, droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite = new Vecteur(point.x - droite.point1.x, point.y - droite.point1.y);\n      let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n      let symetrique = new Vecteur(point.x - 2 * projection * vecteurNormalUnitaire.x, point.y - 2 * projection * vecteurNormalUnitaire.y);\n      return new Point(symetrique.x, symetrique.y);\n    });\n    _defineProperty(this, \"distance\", function (point1) {\n      return Math.sqrt(Math.pow(this.x - point1.x, 2) + Math.pow(this.y - point1.y, 2));\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Point(centre.x + k * (this.x - centre.x), centre.y + k * (this.y - centre.y));\n    });\n    _defineProperty(this, \"homothetiePoint\", function (centre, point) {\n      let k = centre.distance(point) / centre.distance(this);\n      return this.homothetie(centre, k);\n    });\n    _defineProperty(this, \"angle\", function (point1, point2) {\n      // Retourne l'angle orienté entre les vecteurs (this, point1) et (this, point2)\n      let vecteur1 = new Vecteur(point1.x - this.x, point1.y - this.y);\n      let vecteur2 = new Vecteur(point2.x - this.x, point2.y - this.y);\n      return vecteur1.angle(vecteur2);\n    });\n    _defineProperty(this, \"distancePointDroite\", function (A, B) {\n      return (B.x - A.x) * (this.y - A.y) - (B.y - A.y) * (this.x - A.x);\n    });\n    _defineProperty(this, \"projectionOrthogonale\", function (A, B) {\n      // Projection de this sur la droite (AB)\n      let AB = new Vecteur(B.x - A.x, B.y - A.y);\n      let AC = new Vecteur(this.x - A.x, this.y - A.y);\n      let k = AB.produitScalaire(AC) / (AB.norme() * AB.norme());\n      return new Point(A.x + k * AB.x, A.y + k * AB.y);\n    });\n    _defineProperty(this, \"projectionAngle\", function (A, B, angle) {\n      let AB = new Droite();\n      AB.setCoefficientsDroite2Points(A, B);\n      let u = new Vecteur();\n      u.setCoordonneesVecteur2Points(A, B);\n      let v = u.rotation(angle);\n      let C = this.translation(v);\n      let AC = new Droite();\n      AC.setCoefficientsDroite2Points(this, C);\n      return AB.intersection(AC);\n    });\n    this.x = _x;\n    this.y = _y;\n  }\n  rotation(centre, angle) {\n    let dx = this.x - centre.x;\n    let dy = this.y - centre.y;\n    let rotatedX = centre.x + dx * Math.cos(angle) - dy * Math.sin(angle);\n    let rotatedY = centre.y + dx * Math.sin(angle) + dy * Math.cos(angle);\n    return new Point(rotatedX, rotatedY);\n  }\n}\nclass Vecteur {\n  constructor(_x2, _y2) {\n    _defineProperty(this, \"setCoordonneesVecteur\", function (vecteur, x, y) {\n      vecteur.x = x;\n      vecteur.y = y;\n    });\n    // Méthode pour construire le vecteur à partir de deux points\n    _defineProperty(this, \"setCoordonneesVecteur2Points\", function (point1, point2) {\n      this.x = point2.x - point1.x;\n      this.y = point2.y - point1.y;\n    });\n    _defineProperty(this, \"getCoordonneesVecteur\", function () {\n      return [this.x, this.y];\n    });\n    _defineProperty(this, \"additionVecteur\", function (vecteur) {\n      return new Vecteur(this.x + vecteur.x, this.y + vecteur.y);\n    });\n    _defineProperty(this, \"soustractionVecteur\", function (vecteur) {\n      return new Vecteur(this.x - vecteur.x, this.y - vecteur.y);\n    });\n    _defineProperty(this, \"multiplicationVecteur\", function (k) {\n      return new Vecteur(k * this.x, k * this.y);\n    });\n    _defineProperty(this, \"produitScalaire\", function (vecteur) {\n      return this.x * vecteur.x + this.y * vecteur.y;\n    });\n    _defineProperty(this, \"norme\", function () {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    });\n    _defineProperty(this, \"normalisation\", function () {\n      return new Vecteur(this.x / this.norme(), this.y / this.norme());\n    });\n    _defineProperty(this, \"produitVectoriel\", function (vecteur) {\n      return this.x * vecteur.y - this.y * vecteur.x;\n    });\n    _defineProperty(this, \"angle\", function (vecteur) {\n      // Prévoir un angle signé\n      return Math.atan2(this.produitVectoriel(vecteur), this.produitScalaire(vecteur));\n    });\n    _defineProperty(this, \"projection\", function (vecteur) {\n      return this.produitScalaire(vecteur) / this.norme();\n    });\n    _defineProperty(this, \"projectionOrthogonale\", function (vecteur) {\n      return this.produitVectoriel(vecteur) / this.norme();\n    });\n    _defineProperty(this, \"rotation\", function (angle) {\n      return new Vecteur(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));\n    });\n    this.x = _x2;\n    this.y = _y2;\n  }\n}\nclass Cercle {\n  constructor(_centre, _rayon) {\n    _defineProperty(this, \"setCoordonneesCercle\", function (centre, rayon) {\n      this.centre = centre;\n      this.rayon = rayon;\n    });\n    _defineProperty(this, \"getCoordonneesCercle\", function () {\n      return [this.centre, this.rayon];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Cercle(new Point(2 * centre.x - this.centre.x, 2 * centre.y - this.centre.y), this.rayon);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurCentreDroite = new Vecteur(this.centre.x - droite.point1.x, this.centre.y - droite.point1.y);\n      let projection = vecteurNormalUnitaire.x * vecteurCentreDroite.x + vecteurNormalUnitaire.y * vecteurCentreDroite.y;\n      let symetrique = new Vecteur(this.centre.x - 2 * projection * vecteurNormalUnitaire.x, this.centre.y - 2 * projection * vecteurNormalUnitaire.y);\n      return new Cercle(new Point(symetrique.x, symetrique.y), this.rayon);\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Cercle(new Point((this.centre.x - centre.x) * Math.cos(angle) - (this.centre.y - centre.y) * Math.sin(angle) + centre.x, (this.centre.x - centre.x) * Math.sin(angle) + (this.centre.y - centre.y) * Math.cos(angle) + centre.y), this.rayon);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Cercle(new Point(centre.x + k * (this.centre.x - centre.x), centre.y + k * (this.centre.y - centre.y)), k * this.rayon);\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\n    });\n    this.centre = _centre;\n    this.rayon = _rayon;\n  }\n}\nclass Points {\n  constructor(_points) {\n    _defineProperty(this, \"setCoordonneesPoints\", function (points) {\n      this.points = points;\n    });\n    _defineProperty(this, \"getCoordonneesPoints\", function () {\n      return this.points;\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"rotation\", function (angle, center) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point((this.points[i].x - center.x) * Math.cos(angle) - (this.points[i].y - center.y) * Math.sin(angle) + center.x, (this.points[i].x - center.x) * Math.sin(angle) + (this.points[i].y - center.y) * Math.cos(angle) + center.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"symetriecentrale\", function (centre) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(2 * centre.x - this.points[i].x, 2 * centre.y - this.points[i].y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"symetrieaxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        let vecteurPointDroite = new Vecteur(this.points[i].x - droite.point1.x, this.points[i].y - droite.point1.y);\n        let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n        let symetrique = new Vecteur(this.points[i].x - 2 * projection * vecteurNormalUnitaire.x, this.points[i].y - 2 * projection * vecteurNormalUnitaire.y);\n        points.push(new Point(symetrique.x, symetrique.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(centre.x + k * (this.points[i].x - centre.x), centre.y + k * (this.points[i].y - centre.y)));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\n      }\n      return new Points(points);\n    });\n    this.points = _points;\n  }\n}\nclass Droite {\n  constructor(_a, _b, _c) {\n    _defineProperty(this, \"setCoefficientsDroite\", function (a, b, c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    });\n    _defineProperty(this, \"getCoefficientsDroite\", function () {\n      return [this.a, this.b, this.c];\n    });\n    _defineProperty(this, \"setCoefficientsDroite2Points\", function (point1, point2) {\n      this.a = point2.y - point1.y;\n      this.b = point1.x - point2.x;\n      this.c = point1.y * point2.x - point1.x * point2.y;\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Droite(this.a, this.b, this.c + this.a * vecteur.x + this.b * vecteur.y);\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Droite(this.a * Math.cos(angle) - this.b * Math.sin(angle), this.a * Math.sin(angle) + this.b * Math.cos(angle), this.c + this.a * (centre.y - centre.x * Math.sin(angle)) + this.b * (centre.x * Math.cos(angle) - centre.y));\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Droite(this.a, this.b, this.c + 2 * this.a * centre.x + 2 * this.b * centre.y);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite = new Vecteur(this.a, this.b);\n      let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n      let symetrique = new Vecteur(this.a - 2 * projection * vecteurNormalUnitaire.x, this.b - 2 * projection * vecteurNormalUnitaire.y);\n      return new Droite(symetrique.x, symetrique.y, this.c);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Droite(this.a, this.b, this.c + this.a * (centre.x - k * centre.x) + this.b * (centre.y - k * centre.y));\n    });\n    _defineProperty(this, \"perpendiculaire\", function (point) {\n      return new Droite(-this.b, this.a, this.b * point.x - this.a * point.y);\n    });\n    _defineProperty(this, \"parallele\", function (point) {\n      return new Droite(this.a, this.b, this.c - this.a * point.x + this.b * point.y);\n    });\n    _defineProperty(this, \"intersection\", function (droite) {\n      let x = (this.b * droite.c - droite.b * this.c) / (this.a * droite.b - droite.a * this.b);\n      let y = (this.c * droite.a - droite.c * this.a) / (this.a * droite.b - droite.a * this.b);\n      return new Point(x, y);\n    });\n    this.a = _a;\n    this.b = _b;\n    this.c = _c;\n  }\n}\nclass Segment {\n  constructor(_point, _point2) {\n    _defineProperty(this, \"setCoordonneesSegment\", function (point1, point2) {\n      this.point1 = point1;\n      this.point2 = point2;\n    });\n    _defineProperty(this, \"getCoordonneesSegment\", function () {\n      return [this.point1, this.point2];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Segment(new Point(this.point1.x + vecteur.x, this.point1.y + vecteur.y), new Point(this.point2.x + vecteur.x, this.point2.y + vecteur.y));\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Segment(new Point((this.point1.x - centre.x) * Math.cos(angle) - (this.point1.y - centre.y) * Math.sin(angle) + centre.x, (this.point1.x - centre.x) * Math.sin(angle) + (this.point1.y - centre.y) * Math.cos(angle) + centre.y), new Point((this.point2.x - centre.x) * Math.cos(angle) - (this.point2.y - centre.y) * Math.sin(angle) + centre.x, (this.point2.x - centre.x) * Math.sin(angle) + (this.point2.y - centre.y) * Math.cos(angle) + centre.y));\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Segment(new Point(2 * centre.x - this.point1.x, 2 * centre.y - this.point1.y), new Point(2 * centre.x - this.point2.x, 2 * centre.y - this.point2.y));\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite1 = new Vecteur(this.point1.x - droite.point1.x, this.point1.y - droite.point1.y);\n      let projection1 = vecteurNormalUnitaire.x * vecteurPointDroite1.x + vecteurNormalUnitaire.y * vecteurPointDroite1.y;\n      let symetrique1 = new Vecteur(this.point1.x - 2 * projection1 * vecteurNormalUnitaire.x, this.point1.y - 2 * projection1 * vecteurNormalUnitaire.y);\n      let vecteurPointDroite2 = new Vecteur(this.point2.x - droite.point1.x, this.point2.y - droite.point1.y);\n      let projection2 = vecteurNormalUnitaire.x * vecteurPointDroite2.x + vecteurNormalUnitaire.y * vecteurPointDroite2.y;\n      let symetrique2 = new Vecteur(this.point2.x - 2 * projection2 * vecteurNormalUnitaire.x, this.point2.y - 2 * projection2 * vecteurNormalUnitaire.y);\n      return new Segment(new Point(symetrique1.x, symetrique1.y), new Point(symetrique2.x, symetrique2.y));\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Segment(new Point(centre.x + k * (this.point1.x - centre.x), centre.y + k * (this.point1.y - centre.y)), new Point(centre.x + k * (this.point2.x - centre.x), centre.y + k * (this.point2.y - centre.y)));\n    });\n    _defineProperty(this, \"perpendiculaire\", function (point) {\n      let droite = new Droite(this.point1, this.point2);\n      return droite.perpendiculaire(point);\n    });\n    _defineProperty(this, \"parallele\", function (point) {\n      let droite = new Droite(this.point1, this.point2);\n      return droite.parallele(point);\n    });\n    _defineProperty(this, \"milieu\", function () {\n      return new Point((this.point1.x + this.point2.x) / 2, (this.point1.y + this.point2.y) / 2);\n    });\n    _defineProperty(this, \"longueur\", function () {\n      return Math.sqrt(Math.pow(this.point1.x - this.point2.x, 2) + Math.pow(this.point1.y - this.point2.y, 2));\n    });\n    _defineProperty(this, \"angle\", function () {\n      // Retourne l'angle orienté entre le segment et l'axe des abscisses\n      let vecteur = new Vecteur(this.point2.x - this.point1.x, this.point2.y - this.point1.y);\n      return vecteur.angle(new Vecteur(1, 0));\n    });\n    this.point1 = _point;\n    this.point2 = _point2;\n  }\n}\n\n//# sourceURL=webpack://MyLibrary/./src/js/class2.js?");

/***/ }),

/***/ "./src/js/interactif2.js":
/*!*******************************!*\
  !*** ./src/js/interactif2.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListenerInteractivite: () => (/* binding */ addListenerInteractivite),\n/* harmony export */   createFigures: () => (/* binding */ createFigures)\n/* harmony export */ });\n/* harmony import */ var _class2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class2.js */ \"./src/js/class2.js\");\n// Version: 1.0.0\n\n\n// Liste des codages possibles\nvar codagesSegment = [\"M-5,-5 L0,5 M0,-5 L5,5\", \"M-2.5,-5 L2.5,5\", \"M-5,-5 L-1,5 M-1,-5 L3,5 M3,-5 L7,5\", \"M-5,-5 L-2,5 M-2,-5 L1,5 M1,-5 L4,5 M4,-5 L7,5\"];\nvar setUniqueIds = function () {\n  // On récupère toutes les balises de class figure\n  var figures = document.querySelectorAll(\".figure\");\n  // On rend unique les identifiants des éléments constitutifs de la figure\n  for (var i = 0; i < figures.length; i++) {\n    // On récupère l'identifiant de la figure\n    var id = figures[i].id;\n    // on teste si la figure contient un svg\n    if (figures[i].querySelector(\"svg\") != null) {\n      var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*[name]\");\n      // Pour chaque identifiant\n      for (var j = 0; j < ids.length; j++) {\n        // On créé un id pour l'élément\n        ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"name\"));\n\n        // On ajoute également l'identifiant à tous les éléments du linkto\n        if (ids[j].getAttribute(\"linkto\") != null) {\n          var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\n          for (var k = 0; k < linkto.length; k++) {\n            linkto[k] = id + \"-\" + linkto[k];\n          }\n          ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\n        }\n      }\n      // On sélectionne maintenant tous qui n'ont pas la class name\n      var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*:not([name])\");\n      // On ajoute un identifiant s'ils n'ont pas de linkto\n      for (var j = 0; j < ids.length; j++) {\n        if (ids[j].getAttribute(\"linkto\") == null) {\n          ids[j].setAttribute(\"id\", id + \"-\" + j);\n        } else {\n          // On créé un id pour l'élément à partir du linkto\n          // Sauf s'il est de la class label\n          if (!ids[j].classList.contains(\"label\")) {\n            ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"linkto\"));\n          } else {\n            ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"linkto\") + \"-label\");\n          }\n        }\n        // On ajoute également l'identifiant à tous les éléments du linkto\n        if (ids[j].getAttribute(\"linkto\") != null) {\n          var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\n          for (var k = 0; k < linkto.length; k++) {\n            linkto[k] = id + \"-\" + linkto[k];\n          }\n          ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\n        }\n      }\n    }\n  }\n};\nvar addListenerButtonQuadrillage = function (figure) {\n  var quadrillage = figure.querySelector(\"#\" + figure.id + \"-quadrillage\");\n  var bouton = figure.querySelector(\".bouton-quadrillage\");\n  bouton.addEventListener(\"click\", function () {\n    if (quadrillage.style.display == \"none\") {\n      quadrillage.style.display = \"block\";\n    } else {\n      quadrillage.style.display = \"none\";\n    }\n  });\n};\nvar addBoutonQuadrillage = function (figure) {\n  // Tester si la figure a déjà un bouton de la classe bouton-quadrillage\n  if (figure.querySelector(\".bouton-quadrillage\") == null) {\n    // On ajoute un bouton pour afficher/masquer le quadrillage\n    var bouton = document.createElement(\"button\");\n    // Ajouter une classe au bouton\n    bouton.classList.add(\"bouton-quadrillage\");\n    bouton.innerHTML = \"Afficher/masquer le quadrillage\";\n    figure.appendChild(bouton);\n  }\n};\nvar addListenerButtonPleinEcran = function (figure) {\n  var bouton = figure.querySelector(\".bouton-pleinecran\");\n  bouton.addEventListener(\"click\", function () {\n    if (!document.fullscreenElement) {\n      if (figure.requestFullscreen) {\n        figure.requestFullscreen();\n      } else if (figure.webkitRequestFullscreen) {\n        /* Safari */\n        figure.webkitRequestFullscreen();\n      } else if (figure.msRequestFullscreen) {\n        /* IE11 */\n        figure.msRequestFullscreen();\n      }\n    } else {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.webkitExitFullscreen) {\n        /* Safari */\n        document.webkitExitFullScreen();\n      } else if (document.msExitFullscreen) {\n        /* IE11 */\n        document.msExitFullScreen();\n      }\n    }\n  });\n};\nvar addBoutonPleinEcran = function (figure) {\n  if (figure.querySelector(\".bouton-pleinecran\") == null) {\n    var bouton = document.createElement(\"button\");\n    bouton.classList.add(\"bouton-pleinecran\");\n    bouton.innerHTML = \"Plein écran\";\n    figure.appendChild(bouton);\n  }\n};\nvar addQuadrillage = function (figure) {\n  // On ajoute un quadrillage\n  var quadrillage = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  quadrillage.setAttribute(\"id\", \"quadrillage\");\n  // On récupère les dimensions de la figure avec viewBox\n  var viewBox = figure.querySelector(\"svg\").getAttribute(\"viewBox\").split(\" \");\n  var width = parseFloat(viewBox[2]);\n  var height = parseFloat(viewBox[3]);\n  var xmin = parseFloat(viewBox[0]);\n  var ymin = parseFloat(viewBox[1]);\n  // On calcule le nombres de lignes et de colonnes\n  var nblignes = Math.floor(height / 10);\n  var nbcolonnes = Math.floor(width / 10);\n  // On ajoute les lignes verticales\n  for (i = 0; i < nbcolonnes + 1; i++) {\n    var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    ligne.setAttribute(\"x1\", xmin + i * 10);\n    ligne.setAttribute(\"y1\", ymin);\n    ligne.setAttribute(\"x2\", xmin + i * 10);\n    ligne.setAttribute(\"y2\", ymin + height);\n    ligne.setAttribute(\"stroke\", \"gray\");\n    ligne.setAttribute(\"stroke-width\", \"0.2\");\n    quadrillage.appendChild(ligne);\n  }\n  // On ajoute les lignes horizontales\n  for (var i = 0; i < nblignes + 1; i++) {\n    var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    ligne.setAttribute(\"x1\", xmin);\n    ligne.setAttribute(\"y1\", ymin + i * 10);\n    ligne.setAttribute(\"x2\", xmin + width);\n    ligne.setAttribute(\"y2\", ymin + i * 10);\n    ligne.setAttribute(\"stroke\", \"gray\");\n    ligne.setAttribute(\"stroke-width\", \"0.2\");\n    quadrillage.appendChild(ligne);\n  }\n  if (!figure.querySelector(\"svg\").classList.contains(\"quadrillage\")) {\n    quadrillage.style.display = \"none\";\n  }\n  quadrillage.style.userSelect = \"none\";\n  quadrillage.style.pointerEvents = \"none\";\n  quadrillage.id = figure.id + \"-quadrillage\";\n  // On place un cadre autour du quadrillage\n  var cadre = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  cadre.setAttribute(\"x\", xmin);\n  cadre.setAttribute(\"y\", ymin);\n  cadre.setAttribute(\"width\", width);\n  cadre.setAttribute(\"height\", height);\n  cadre.setAttribute(\"fill\", \"lightgray\");\n  cadre.setAttribute(\"fill-opacity\", \"0.2\");\n  // Avec un effet d'ombre\n  figure.querySelector(\"svg\").prepend(quadrillage);\n  figure.querySelector(\"svg\").prepend(cadre);\n};\nvar getLinkto = function (objet) {\n  return objet.getAttribute(\"linkto\").split(\" \");\n};\nvar getElementLinkto = function (objet, n) {\n  return document.getElementById(getLinkto(objet)[n]);\n};\nvar constructLabelPoint = function (point) {\n  if (point.classList.contains(\"labeled\")) {\n    var idfigure = point.id.split(\"-\")[0];\n    var labels = document.getElementById(idfigure).querySelectorAll(\"g.label\");\n    var labelLinkto = Array.from(labels).filter(label => label.getAttribute(\"linkto\") == point.id);\n    var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n    if (labelLinkto.length == 0) {\n      foreignObject.setAttribute(\"x\", \"0\");\n      foreignObject.setAttribute(\"y\", \"0\");\n      foreignObject.setAttribute(\"text-anchor\", \"start\");\n      foreignObject.setAttribute(\"width\", \"20\");\n      foreignObject.setAttribute(\"height\", \"20\");\n      foreignObject.setAttribute(\"style\", point.getAttribute(\"style\"));\n      foreignObject.innerHTML = katex.renderToString(point.getAttribute(\"name\"), {\n        output: \"mathml\"\n      });\n    } else {\n      var label = labelLinkto[0];\n      if (label.hasAttribute(\"x\")) {\n        foreignObject.setAttribute(\"x\", label.getAttribute(\"x\"));\n      } else {\n        foreignObject.setAttribute(\"x\", \"0\");\n      }\n      if (label.hasAttribute(\"y\")) {\n        foreignObject.setAttribute(\"y\", label.getAttribute(\"y\"));\n      } else {\n        foreignObject.setAttribute(\"y\", \"0\");\n      }\n      if (label.hasAttribute(\"width\")) {\n        foreignObject.setAttribute(\"width\", label.getAttribute(\"width\"));\n      } else {\n        foreignObject.setAttribute(\"width\", \"20\");\n      }\n      if (label.hasAttribute(\"height\")) {\n        foreignObject.setAttribute(\"height\", label.getAttribute(\"height\"));\n      } else {\n        foreignObject.setAttribute(\"height\", \"20\");\n      }\n      if (label.hasAttribute(\"text-anchor\")) {\n        foreignObject.setAttribute(\"text-anchor\", label.getAttribute(\"text-anchor\"));\n      } else {\n        foreignObject.setAttribute(\"text-anchor\", \"middle\");\n      }\n      if (label.hasAttribute(\"fill\")) {\n        foreignObject.setAttribute(\"fill\", label.getAttribute(\"fill\"));\n      } else {\n        foreignObject.setAttribute(\"fill\", \"black\");\n      }\n      if (label.hasAttribute(\"stroke\")) {\n        foreignObject.setAttribute(\"stroke\", label.getAttribute(\"stroke\"));\n      } else {\n        foreignObject.setAttribute(\"stroke\", \"stroke\");\n      }\n      foreignObject.setAttribute(\"style\", labelLinkto[0].getAttribute(\"style\"));\n      foreignObject.innerHTML = katex.renderToString(label.innerHTML, {\n        output: \"mathml\"\n      });\n    }\n    foreignObject.style.userSelect = \"none\";\n    point.appendChild(foreignObject);\n  }\n};\nvar constructCrossPoint = function (point) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M-2,-2 L2,2 M-2,2 L2,-2\");\n  path.setAttribute(\"fill\", \"transparent\");\n  path.setAttribute(\"stroke\", \"black\");\n  path.setAttribute(\"class\", \"crosspoint\");\n  path.style.userSelect = \"none\";\n  // Récupérer le style du point\n  var style = point.getAttribute(\"style\");\n  path.setAttribute(\"style\", style);\n  point.appendChild(path);\n};\nvar automaticHideCrossPoint = function (point) {\n  var idfigure = point.id.split(\"-\")[0];\n  getPolygonesFigure(idfigure).forEach(function (polygone) {\n    var linkto = getLinkto(polygone);\n    if (linkto.includes(point.id)) {\n      point.querySelector(\"path.crosspoint\").setAttribute(\"stroke\", \"transparent\");\n    }\n  });\n};\nvar constructHightlightPoint = function (point) {\n  if (point.classList.contains(\"draggable\")) {\n    var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"class\", \"selectionne\");\n    circle.setAttribute(\"cx\", \"0\");\n    circle.setAttribute(\"cy\", \"0\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill-opacity\", \"0.2\");\n    circle.setAttribute(\"r\", \"0\");\n    circle.style.userSelect = \"none\";\n    point.prepend(circle);\n  }\n};\nvar constructSelectPoint = function (point) {\n  if (point.classList.contains(\"draggable\")) {\n    var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"class\", \"selectionneur\");\n    circle.setAttribute(\"cx\", \"0\");\n    circle.setAttribute(\"cy\", \"0\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    circle.setAttribute(\"r\", \"4\");\n    point.appendChild(circle);\n  }\n};\nvar getPointsFigure = function (figure) {\n  var points = document.querySelectorAll(\"g.point\");\n  var pointsArray = Array.from(points);\n  return pointsArray.filter(point => point.id.split(\"-\")[0] == figure.id);\n};\nvar initialiserPointTransform = function (point) {\n  var x = 0;\n  var y = 0;\n  if (point.hasAttribute(\"x\")) {\n    x = point.getAttribute(\"x\");\n  }\n  if (point.hasAttribute(\"y\")) {\n    y = point.getAttribute(\"y\");\n  }\n  point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nvar getPolygonesFigure = function (idfigure) {\n  var polygones = document.querySelectorAll(\"g.polygone\");\n  var polygonesArray = Array.from(polygones);\n  return polygonesArray.filter(polygone => polygone.id.split(\"-\")[0] == idfigure);\n};\nvar getVecteursFigure = function (figure) {\n  var vecteurs = document.querySelectorAll(\"g.vecteur\");\n  var vecteursArray = Array.from(vecteurs);\n  return vecteursArray.filter(vecteur => vecteur.id.split(\"-\")[0] == figure.id);\n};\nvar constructHeadVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M-7,-2 L-0,-0 L-7,2\");\n  // Déterminer les coordonnées relatives de B par rappport à A\n  path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\n  path.setAttribute(\"fill\", \"black\");\n  path.setAttribute(\"stroke-width\", \"0.5\");\n  path.classList.add(\"headVecteur\");\n  path.style.userSelect = \"none\";\n  setStroke(vecteur, path);\n  // Ajouter le style du vecteur au path\n  path.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  // Si dans le style il y a un stroke alors on ajoute la même couleur au fill du path\n  if (vecteur.getAttribute(\"style\") != null && vecteur.getAttribute(\"style\").includes(\"stroke\")) {\n    // Récupérer le stroke du style\n    var stroke = vecteur.getAttribute(\"style\").split(\";\").filter(style => style.includes(\"stroke\"))[0];\n    // Récupérer la couleur du stroke\n    var color = stroke.split(\":\")[1];\n    path.setAttribute(\"fill\", color);\n  }\n  vecteur.appendChild(path);\n};\nvar constructLabelVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n  foreignObject.setAttribute(\"x\", I.x);\n  foreignObject.setAttribute(\"y\", I.y);\n  foreignObject.setAttribute(\"width\", \"20\");\n  foreignObject.setAttribute(\"height\", \"20\");\n  foreignObject.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  // Ajouter le style du vecteur\n  foreignObject.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  foreignObject.innerHTML = katex.renderToString(\"\\\\overrightarrow{\" + vecteur.getAttribute(\"name\") + \"}\", {\n    output: \"mathml\"\n  });\n  foreignObject.style.userSelect = \"none\";\n  vecteur.appendChild(foreignObject);\n};\nvar constructVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\n  setStroke(vecteur, path);\n  vecteur.appendChild(path);\n  constructHeadVecteur(vecteur);\n  // Ajouter le style du vecteur au path\n  path.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  if (vecteur.classList.contains(\"labeled\")) {\n    constructLabelVecteur(vecteur);\n  }\n};\nvar initialiserVecteur = function (vecteur) {\n  constructVecteur(vecteur);\n};\nvar initialiserVecteursFigure = function (figure) {\n  getVecteursFigure(figure).forEach(function (vecteur) {\n    initialiserVecteur(vecteur);\n  });\n};\nvar getDroitesFigure = function (figure) {\n  var droites = document.querySelectorAll(\"g.droite\");\n  var droitesArray = Array.from(droites);\n  return droitesArray.filter(droite => droite.id.split(\"-\")[0] == figure.id);\n};\nvar determinerExtremitesDroite = function (droite) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n  AB.setCoordonneesVecteur2Points(A, B);\n  var u = AB.normalisation();\n  var E1 = A.translation(u.multiplicationVecteur(-200));\n  var E2 = A.translation(u.multiplicationVecteur(200));\n  return [E1, E2];\n};\nvar setStroke = function (objet, path) {\n  var stroke = objet.hasAttribute(\"stroke\") ? objet.getAttribute(\"stroke\") : \"black\";\n  path.setAttribute(\"stroke\", stroke);\n  var strokewidth = objet.hasAttribute(\"stroke-width\") ? objet.getAttribute(\"stroke-width\") : \"0.5\";\n  path.setAttribute(\"stroke-width\", strokewidth);\n  // Si c'est un vecteur il faut que le fill soit le même que le srtoke du vecteur\n  if (objet.classList.contains(\"vecteur\")) {\n    path.setAttribute(\"fill\", stroke);\n  }\n};\nvar constructDroite = function (droite) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var extremites = determinerExtremitesDroite(droite);\n  var E1 = extremites[0];\n  var E2 = extremites[1];\n  path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\n  setStroke(droite, path);\n  droite.appendChild(path);\n};\nvar initialiserDroite = function (droite) {\n  constructDroite(droite);\n};\nvar initialiserDroitesFigure = function (figure) {\n  getDroitesFigure(figure).forEach(function (droite) {\n    initialiserDroite(droite);\n  });\n};\nvar getDemidroitesFigure = function (figure) {\n  var demidroites = document.querySelectorAll(\"g.demidroite\");\n  var demidroitesArray = Array.from(demidroites);\n  return demidroitesArray.filter(demidroite => demidroite.id.split(\"-\")[0] == figure.id);\n};\nvar constructDemiDroite = function (demidroite) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(demidroite, 0)));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var extremites = determinerExtremitesDroite(demidroite);\n  var E = extremites[1];\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + E.x + \",\" + E.y);\n  setStroke(demidroite, path);\n  demidroite.appendChild(path);\n};\nvar initialiserDemiDroite = function (demidroite) {\n  constructDemiDroite(demidroite);\n};\nvar initialiserDemiDroitesFigure = function (figure) {\n  getDemidroitesFigure(figure).forEach(function (demidroite) {\n    initialiserDemiDroite(demidroite);\n  });\n};\nvar getSegmentsFigure = function (figure) {\n  var segments = document.querySelectorAll(\"g.segment\");\n  var segmentsArray = Array.from(segments);\n  return segmentsArray.filter(segment => segment.id.split(\"-\")[0] == figure.id);\n};\nvar constructCodageSegment = function (segment, codage) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"fill\", \"transparent\");\n  path.setAttribute(\"stroke\", \"black\");\n  path.setAttribute(\"stroke-width\", \"0.8\");\n  path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + alpha + \")\");\n  path.setAttribute(\"d\", codage);\n  path.style.userSelect = \"none\";\n  path.classList.add(\"codageSegment\");\n  segment.appendChild(path);\n};\nvar isCodageSegment = function (segment) {\n  return segment.classList.contains(\"codage\");\n};\nvar isSegmentLie = function (segment) {\n  // Dans linkto, on a l'id des deux points et éventuellement l'id d'un segment lié par le codage\n  var linkto = getLinkto(segment);\n  return linkto.length == 3;\n};\nvar getSegmentLie = function (segment) {\n  var linkto = getLinkto(segment);\n  return document.getElementById(linkto[2]);\n};\nvar getCodageSegmentLie = function (segment) {\n  var linkto = getLinkto(segment);\n  return getSegmentLie(segment).querySelector(\"path.codageSegment\").getAttribute(\"d\");\n};\nvar listeCodagesFigure = function (objet) {\n  var idfigure = objet.id.split(\"-\")[0];\n  var codages = document.querySelectorAll(\"g.codage\");\n  var codagesArray = Array.from(codages);\n  var codagesFigure = codagesArray.filter(codage => codage.id.split(\"-\")[0] == idfigure).filter(codage => codage.querySelector(\"path.codageSegment\") != null).map(\n  // On récupère l'attribut d\n  codage => codage.querySelector(\"path.codageSegment\").getAttribute(\"d\"));\n  return codagesFigure;\n};\nvar nouveauCodageSegment = function (segment) {\n  var codageExistants = listeCodagesFigure(segment);\n  // On veut un codage qui n'existe pas déjà\n  var i = 0;\n  while (codageExistants.includes(codagesSegment[i])) {\n    i++;\n    if (i == codagesSegment.length) {\n      break;\n    }\n  }\n  if (i < codagesSegment.length) {\n    return codagesSegment[i];\n  } else {\n    // Plus de codages disponibles\n    return \"\";\n  }\n};\nvar constructSegment = function (segment) {\n  var A = getElementLinkto(segment, 0);\n  var B = getElementLinkto(segment, 1);\n  // Construire un élément path\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  // A est l'origine et B l'extrémité du path\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\n  setStroke(segment, path);\n  segment.appendChild(path);\n  if (isCodageSegment(segment)) {\n    if (isSegmentLie(segment)) {\n      constructCodageSegment(segment, getCodageSegmentLie(segment));\n    } else {\n      constructCodageSegment(segment, nouveauCodageSegment(segment));\n    }\n  }\n};\nvar initialiserSegment = function (segment) {\n  constructSegment(segment);\n};\nvar initialiserSegmentsFigure = function (figure) {\n  getSegmentsFigure(figure).forEach(function (segment) {\n    initialiserSegment(segment);\n  });\n};\nvar constructPolygone = function (polygone) {\n  var points = getLinkto(polygone).map(point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))).map(point => [point.x, point.y].join(','));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var d = \"M\" + points.join(\" L\") + \" Z\";\n  path.setAttribute(\"d\", d);\n  setStroke(polygone, path);\n  path.setAttribute(\"style\", polygone.getAttribute(\"style\"));\n  polygone.appendChild(path);\n};\nvar initialiserPolygone = function (polygone) {\n  constructPolygone(polygone);\n};\nvar initialiserPolygonesFigure = function (figure) {\n  getPolygonesFigure(figure.id).forEach(function (polygone) {\n    initialiserPolygone(polygone);\n  });\n};\nvar getGraduationsFigure = function (figure) {\n  var graduations = document.querySelectorAll(\"g.graduation\");\n  var graduationsArray = Array.from(graduations);\n  return graduationsArray.filter(graduation => graduation.id.split(\"-\")[0] == figure.id);\n};\nvar constructGraduation = function (graduation) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(graduation, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(graduation, 1)));\n  var parametres = eval('({' + graduation.getAttribute(\"parametres\") + '})');\n  // Si parametres.vsize n'existe pas alors on prend 4\n  if (parametres.vsize == undefined) {\n    parametres.vsize = 4;\n  }\n  if (parametres.distance == undefined) {\n    parametres.distance = 10;\n  }\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(0, 0);\n  AB.setCoordonneesVecteur2Points(A, B);\n  var u = AB.normalisation();\n  var graduations = [];\n  for (var i = 0; i < parametres.n + 1; i++) {\n    graduations.push(A.translation(u.multiplicationVecteur(i * AB.norme() / parametres.n)));\n  }\n  // Construire les graduations de taille verticale vsize\n  var graduationsSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  var style = graduation.getAttribute(\"style\");\n  graduationsSVG.setAttribute(\"style\", style);\n  for (var i = 0; i < parametres.n + 1; i++) {\n    var graduationSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    // La graduation est pour moitié en dessous et pour moitié au dessus du point\n    // La graduation doit être orientée selon le vecteur u\n    var x1 = graduations[i].x - parametres.vsize / 2 * u.y;\n    var y1 = graduations[i].y + parametres.vsize / 2 * u.x;\n    var x2 = graduations[i].x + parametres.vsize / 2 * u.y;\n    var y2 = graduations[i].y - parametres.vsize / 2 * u.x;\n    graduationSVG.setAttribute(\"d\", \"M\" + x1 + \",\" + y1 + \" L\" + x2 + \",\" + y2);\n    graduationSVG.setAttribute(\"stroke\", \"black\");\n    graduationSVG.setAttribute(\"stroke-width\", \"0.5\");\n    graduationSVG.style.userSelect = \"none\";\n    graduationsSVG.appendChild(graduationSVG);\n  }\n  // On ajoute maintenant les abscisses des graduations si la class abscisses est présente\n  if (graduation.classList.contains(\"abscisses\")) {\n    // Si parametres.nmin n'existe pas alors on prend 0\n    if (parametres.nmin == undefined) {\n      parametres.nmin = 0;\n    }\n    var angle = Math.atan2(u.y, u.x); // Angle de u par rapport à l'axe des abscisses\n\n    var abscissesSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    for (var i = 0; i < parametres.n + 1; i++) {\n      var abscisseSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      var offsetX = 0,\n        offsetY = parametres.distance; // Par défaut, placez les abscisses en dessous\n\n      // Si l'angle est dans le 2ème ou 3ème quadrant, placez les abscisses au-dessus\n      if (angle > Math.PI / 2 && angle < 3 * Math.PI / 2) {\n        offsetY = -parametres.distance;\n      }\n      abscisseSVG.setAttribute(\"x\", graduations[i].x + offsetX);\n      abscisseSVG.setAttribute(\"y\", graduations[i].y + offsetY);\n      abscisseSVG.setAttribute(\"text-anchor\", \"middle\");\n      abscisseSVG.setAttribute(\"font-size\", \"10\");\n      abscisseSVG.setAttribute(\"fill\", \"black\");\n      abscisseSVG.setAttribute(\"stroke\", \"transparent\");\n      abscisseSVG.setAttribute(\"stroke-width\", \"0.5\");\n      abscisseSVG.setAttribute(\"style\", \"user-select:none\");\n      abscisseSVG.setAttribute(\"style\", style);\n      abscisseSVG.innerHTML = (parametres.nmin + i * (parametres.nmax - parametres.nmin) / parametres.n).toFixed(0);\n      graduationsSVG.appendChild(abscisseSVG);\n    }\n  }\n  graduation.appendChild(graduationsSVG);\n};\nvar initialiserGraduation = function (graduation) {\n  constructGraduation(graduation);\n};\nvar initialiserGraduationsFigure = function (figure) {\n  getGraduationsFigure(figure).forEach(function (graduation) {\n    initialiserGraduation(graduation);\n  });\n};\nvar initialiserFigure = function (figure) {\n  addQuadrillage(figure);\n  addBoutonQuadrillage(figure);\n  addBoutonPleinEcran(figure);\n  initialiserPointsFigure(figure);\n  initialiserVecteursFigure(figure);\n  initialiserDroitesFigure(figure);\n  initialiserDemiDroitesFigure(figure);\n  initialiserSegmentsFigure(figure);\n  initialiserPolygonesFigure(figure);\n  initialiserGraduationsFigure(figure);\n};\nvar getCoordonneesPoint = function (point) {\n  var data = point.getAttribute(\"transform\").split(\"translate(\")[1].split(\")\")[0].split(\",\");\n  var x = parseFloat(data[0]);\n  var y = parseFloat(data[1]);\n  return [x, y];\n};\nvar setCoordonneesPoint = function (point, x, y) {\n  point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nvar actualiserCoordonneesPointClassTranslation = function (point) {\n  if (point.classList.contains(\"translation\")) {\n    // M est l'image de P par la translation de vecteur kAB\n    var A = getElementLinkto(point, 0);\n    var B = getElementLinkto(point, 1);\n    var P = getElementLinkto(point, 2);\n    let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\n    let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\n    let u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    u.setCoordonneesVecteur2Points(P1, P2);\n    let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var k = parseFloat(data[0]);\n    let P4 = P3.translation(u.multiplicationVecteur(k));\n    var x4 = P4.x;\n    var y4 = P4.y;\n    setCoordonneesPoint(point, x4, y4);\n  }\n};\nvar actualiserCoordonneesPointClassDilatation = function (point) {\n  if (point.classList.contains(\"dilatation\")) {\n    // H est le projeté de P selon la direction formant un angle alpha avec le vecteur AB\n    // M est l'image de P par l'homothétie de rapport k et de centre H \n    var A = getElementLinkto(point, 0);\n    var B = getElementLinkto(point, 1);\n    var P = getElementLinkto(point, 2);\n    let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\n    let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\n    let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var k = parseFloat(data[1]);\n    var alpha = parseFloat(data[0]) / 180 * Math.PI;\n    var H = P3.projectionAngle(P1, P2, alpha);\n    var M = P3.homothetie(H, k);\n    setCoordonneesPoint(point, M.x, M.y);\n  }\n};\nvar actualiserCoordonneesPointClassRotation = function (point) {\n  if (point.classList.contains(\"rotation\")) {\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var alpha = parseFloat(data[0]) / 180 * Math.PI;\n    if (getLinkto(point).length == 1) {\n      var k = parseFloat(data[1]);\n      var P = A.translation(new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0));\n      var M = P.rotation(A, alpha).homothetie(A, k);\n    } else if (getLinkto(point).length == 2) {\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var k = parseFloat(data[1]);\n      var M = P.rotation(A, alpha).homothetie(A, k);\n    } else if (getLinkto(point).length == 3) {\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n      var k = parseFloat(data[1]);\n      var N = P.rotation(A, alpha).homothetie(A, k);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      u.setCoordonneesVecteur2Points(A, Q);\n      M = N.translation(u);\n    }\n    setCoordonneesPoint(point, M.x, M.y);\n  }\n};\nvar actualiserCoordonneesPointsLies = function (point) {\n  // Récursivité pour atteindre tous les points liés\n  var idPoint = point.getAttribute(\"id\");\n  var points = document.querySelectorAll(\"g.point[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < points.length; i++) {\n    actualiserCoordonneesPoint(points[i]);\n  }\n};\nvar initialiserDataPoint = function (point) {\n  // Si le point subit une tranformation, on initialise l'attribut data si ce n'est pas déjà fait\n  if (point.hasAttribute(\"data\") == false) {\n    if (point.classList.contains(\"translation\")) {\n      point.setAttribute(\"data\", \"1\");\n      point.classList.add(\"transformation\");\n    } else if (point.classList.contains(\"dilatation\")) {\n      point.setAttribute(\"data\", \"90 -1\");\n      point.classList.add(\"transformation\");\n    } else if (point.classList.contains(\"rotation\")) {\n      point.setAttribute(\"data\", \"90 1\");\n      point.classList.add(\"transformation\");\n    }\n  } else {\n    point.classList.add(\"transformation\");\n  }\n};\nvar actualiserLabelVecteur = function (vecteur) {\n  if (vecteur.classList.contains(\"labeled\")) {\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n    var I = AB.milieu();\n    var foreignObject = vecteur.querySelector(\"foreignObject\");\n    foreignObject.setAttribute(\"x\", I.x);\n    foreignObject.setAttribute(\"y\", I.y);\n  }\n};\nvar actualiserVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var path = vecteur.querySelector(\"path\");\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\n  actualiserHeadVecteur(vecteur);\n  actualiserLabelVecteur(vecteur);\n};\nvar actualiserCoordonneesVecteursLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var vecteurs = document.querySelectorAll(\"g.vecteur[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < vecteurs.length; i++) {\n    actualiserVecteur(vecteurs[i]);\n  }\n};\nvar actualiserDroite = function (droite) {\n  var path = droite.querySelector(\"path\");\n  var extremites = determinerExtremitesDroite(droite);\n  var E1 = extremites[0];\n  var E2 = extremites[1];\n  path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\n};\nvar actualiserCoordonneesDroitesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var droites = document.querySelectorAll(\"g.droite[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < droites.length; i++) {\n    actualiserDroite(droites[i]);\n  }\n};\nvar actualiserDemiDroite = function (demidroite) {\n  var path = demidroite.querySelector(\"path\");\n  var extremites = determinerExtremitesDroite(demidroite);\n  var E = extremites[1];\n  var A = getElementLinkto(demidroite, 0);\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + E.x + \",\" + E.y);\n};\nvar actualiserCoordonneesDemiDroitesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var demidroites = document.querySelectorAll(\"g.demidroite[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < demidroites.length; i++) {\n    actualiserDemiDroite(demidroites[i]);\n  }\n};\nvar actualiserCodageSegment = function (segment) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = segment.querySelector(\"path.codageSegment\");\n  path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + -alpha + \")\");\n};\nvar actualiserHeadVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = vecteur.querySelector(\"path.headVecteur\");\n  path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\n};\nvar actualiserSegment = function (segment) {\n  var A = getElementLinkto(segment, 0);\n  var B = getElementLinkto(segment, 1);\n  var path = segment.querySelector(\"path\");\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\n  if (isCodageSegment(segment)) {\n    actualiserCodageSegment(segment);\n  }\n};\nvar actualiserCoordonneesSegmentsLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var segments = document.querySelectorAll(\"g.segment[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < segments.length; i++) {\n    actualiserSegment(segments[i]);\n  }\n};\nvar actualiserPolygone = function (polygone) {\n  var points = getLinkto(polygone).map(point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))).map(point => [point.x, point.y].join(','));\n  var path = polygone.querySelector(\"path\");\n  var d = \"M\" + points.join(\" L\") + \" Z\";\n  path.setAttribute(\"d\", d);\n};\nvar actualiserCoordonneesPolygonesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var polygones = document.querySelectorAll(\"g.polygone[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < polygones.length; i++) {\n    actualiserPolygone(polygones[i]);\n  }\n};\nvar actualiserCoordonneesPoint = function (point) {\n  actualiserCoordonneesPointClassTranslation(point);\n  actualiserCoordonneesPointClassDilatation(point);\n  actualiserCoordonneesPointClassRotation(point);\n  actualiserCoordonneesPointsLies(point);\n  actualiserCoordonneesVecteursLies(point);\n  actualiserCoordonneesDroitesLies(point);\n  actualiserCoordonneesDemiDroitesLies(point);\n  actualiserCoordonneesSegmentsLies(point);\n  actualiserCoordonneesPolygonesLies(point);\n};\nvar actualiserPointsFigure = function (figure) {\n  getPointsFigure(figure).forEach(function (point) {\n    actualiserCoordonneesPoint(point);\n  });\n};\nvar setHightlightPointOn = function (point) {\n  d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"orange\");\n  d3.select(point).select(\"circle.selectionne\").attr(\"r\", \"20\");\n};\nvar setHightlightPointOff = function (point) {\n  d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"transparent\");\n  d3.select(point).select(\"circle.selectionne\").attr(\"r\", \"0\");\n};\nvar controlerCoordonneesPoint = function (point, figure) {\n  let x = 0;\n  let y = 0;\n  // Points draggable avec contrainte\n  if (point.classList.contains(\"translation\")) {\n    // On détermine le projeté orthogonal du pointeur de la souris sur la droite parallèle à (AB) et passant par P\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n    var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n    var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n    var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    u.setCoordonneesVecteur2Points(A, B);\n    var Q = P.translation(u);\n    var N = M.projectionOrthogonale(P, Q);\n    x = N.x;\n    y = N.y;\n    // On veut la obtenir le rapport signé de la distance PN sur la distance AB\n    var k = P.distance(N) / A.distance(B);\n    // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\n    var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    v.setCoordonneesVecteur2Points(P, N);\n    if (u.produitScalaire(v) < 0) {\n      k = -k;\n    }\n    point.setAttribute(\"data\", k.toString());\n  } else if (point.classList.contains(\"rotation\")) {\n    // Tester le nombre de points liés\n    // Si un seul point\n    if (point.getAttribute(\"linkto\").split(\" \").length == 1) {\n      var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n      var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n      var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n      var d = A.distance(M);\n      var N = M.homothetie(A, k / d);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0);\n      var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      v.setCoordonneesVecteur2Points(A, N);\n      var alpha = u.angle(v) / Math.PI * 180;\n      point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n      x = N.x;\n      y = N.y;\n    } else if (point.getAttribute(\"linkto\").split(\" \").length == 2) {\n      if (!point.classList.contains(\"rapport\")) {\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n        var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n        var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n        var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        u.setCoordonneesVecteur2Points(A, B);\n        var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        v.setCoordonneesVecteur2Points(A, M);\n        var alpha = u.angle(v) / Math.PI * 180;\n        point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n        var N = M.homothetie(A, k);\n        x = N.x;\n        y = N.y;\n      } else {\n        // On conserve l'angle mais on change le rapport\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n        var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n        var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        u.setCoordonneesVecteur2Points(A, B);\n        var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        v.setCoordonneesVecteur2Points(A, M);\n        // Déterminer le signe avec le produit vectoriel\n        var signe = u.produitVectoriel(v) / Math.abs(u.produitVectoriel(v));\n        // On projète M sur l'image de la droite (AB) par la rotation de centre A et d'angle alpha\n        var alpha = parseFloat(point.getAttribute(\"data\").split(\" \")[0]) / 180 * Math.PI;\n        var P1 = B.rotation(A, alpha);\n        var N = M.projectionOrthogonale(A, P1);\n        var k = signe * A.distance(N) / A.distance(B);\n        // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\n        point.setAttribute(\"data\", (alpha / Math.PI * 180).toString() + \" \" + k.toString());\n        x = N.x;\n        y = N.y;\n      }\n    } else if (point.getAttribute(\"linkto\").split(\" \").length == 3) {\n      // Les points sont A, P, Q tels que AQ=AP\n      // Le centre de rotation est maintenant Q mais on veut que le rayon soit toujours AP\n      var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n      var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n      var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      u.setCoordonneesVecteur2Points(A, P);\n      var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      v.setCoordonneesVecteur2Points(Q, M);\n      var alpha = u.angle(v) / Math.PI * 180;\n      point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n      var N = M.homothetie(Q, k);\n      x = N.x;\n      y = N.y;\n    }\n  } else {\n    // Il ne faut pas dépasser les limites du cadre\n    // On récupère les dimensions du cadre avec le viewBox\n    var cadre = figure.querySelector(\"svg\");\n    var viewBox = cadre.getAttribute(\"viewBox\").split(\" \");\n    var xmin = parseFloat(viewBox[0]);\n    var ymin = parseFloat(viewBox[1]);\n    var width = parseFloat(viewBox[2]);\n    var height = parseFloat(viewBox[3]);\n    x = Math.min(Math.max(d3.event.x, xmin), xmin + width);\n    y = Math.min(Math.max(d3.event.y, ymin), ymin + height);\n    // Si le quadrillage est affiché, on déplace le point sur le quadrillage\n    if (figure.querySelector(\"#\" + figure.id + \"-quadrillage\").style.display == \"block\") {\n      x = Math.round(x / 10) * 10;\n      y = Math.round(y / 10) * 10;\n    }\n  }\n  return [x, y];\n};\nvar interactivity = function (figure) {\n  d3.selectAll(\"g.point.draggable\").call(d3.drag().on(\"drag\", function () {\n    if (d3.event.x > 0 && d3.event.x < 200 && d3.event.y > 0 && d3.event.y < 200) {\n      setHightlightPointOn(this);\n      setCoordonneesPoint(this, ...controlerCoordonneesPoint(this, figure));\n      actualiserCoordonneesPoint(this);\n    }\n  }).on(\"end\", function () {\n    setHightlightPointOff(this);\n  }));\n};\nvar initialiserPointsFigure = function (figure) {\n  getPointsFigure(figure).filter(point => point.id.split(\"-\")[0] == figure.id).forEach(function (point) {\n    initialiserPointTransform(point);\n    constructLabelPoint(point);\n    constructCrossPoint(point);\n    constructHightlightPoint(point);\n    constructSelectPoint(point);\n    automaticHideCrossPoint(point);\n    initialiserDataPoint(point);\n  });\n};\nvar draggablesAuPremierPlan = function (figure) {\n  var svg = figure.querySelector(\"svg\");\n  var draggable = figure.querySelectorAll(\".draggable\");\n  for (var i = 0; i < draggable.length; i++) {\n    svg.appendChild(draggable[i]);\n  }\n};\nvar addListenerInteractivite = function (figure) {\n  addListenerButtonQuadrillage(figure);\n  addListenerButtonPleinEcran(figure);\n  figure.addEventListener(\"mouseenter\", function () {\n    interactivity(this);\n  });\n};\n\n// Créer les figures\nvar createFigures = function () {\n  setUniqueIds();\n  var figures = document.querySelectorAll(\".figure\");\n  for (var i = 0; i < figures.length; i++) {\n    if (figures[i].querySelector(\"svg\") != null) {\n      initialiserFigure(figures[i]);\n      actualiserPointsFigure(figures[i]);\n      draggablesAuPremierPlan(figures[i]);\n      addListenerInteractivite(figures[i]);\n    }\n  }\n  window.parent.postMessage(\"figures_created\", \"*\");\n};\n\n//# sourceURL=webpack://MyLibrary/./src/js/interactif2.js?");

/***/ }),

/***/ "./src/js/quiz.js":
/*!************************!*\
  !*** ./src/js/quiz.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _interactif2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interactif2.js */ \"./src/js/interactif2.js\");\n/* harmony import */ var _SCORM_API_wrapper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SCORM_API_wrapper.js */ \"./src/js/SCORM_API_wrapper.js\");\n\n\nvar scorm = _SCORM_API_wrapper_js__WEBPACK_IMPORTED_MODULE_1__.pipwerks.SCORM;\nfunction init() {\n  //\tscorm.version = \"1.2\"; // auto if not specified\n  scorm.init();\n}\nfunction set(param, value) {\n  scorm.set(param, value);\n}\nfunction get(param) {\n  scorm.get(param);\n}\nfunction end() {\n  scorm.quit();\n}\nwindow.onload = function () {\n  init();\n  // var studentId = scorm.get(\"cmi.core.student_id\");\n  // console.log(studentId);\n};\n\nwindow.onunload = function () {\n  end();\n};\nfunction envoyerScore(score) {\n  scorm.status(\"set\", \"completed\");\n  scorm.set(\"cmi.core.score.raw\", score.toString());\n  scorm.set(\"cmi.core.score.min\", \"0\");\n  scorm.set(\"cmi.core.score.max\", \"100\");\n  scorm.set(\"cmi.core.score.scaled\", \"1\");\n  if (score < 100) {\n    scorm.set(\"cmi.success_status\", \"failed\");\n  } else {\n    scorm.set(\"cmi.success_status\", \"passed\");\n  }\n  scorm.save();\n}\n\n// Début du traitement\nfunction disableRadios() {\n  var radios = document.getElementsByName('choix');\n  for (var i = 0, length = radios.length; i < length; i++) {\n    radios[i].disabled = false;\n    radios[i].checked = false;\n  }\n}\nfunction hideCorrection(choix) {\n  for (var i = 0, length = choix.length; i < length; i++) {\n    choix[i].style.background = \"none\";\n  }\n}\nfunction hideValider() {\n  document.getElementById(\"Valider\").style.display = \"none\";\n}\nfunction setValider(text) {\n  document.getElementById(\"Valider\").innerHTML = text;\n}\nfunction getReponsesPossibles(qcm) {\n  var reponsesQCM = qcm.getElementsByClassName('reponse');\n  var answers = [{\n    id: \"c\",\n    text: reponsesQCM[0].innnerHTML\n  }, {\n    id: \"f1\",\n    text: reponsesQCM[1].innnerHTML\n  }, {\n    id: \"f2\",\n    text: reponsesQCM[2].innnerHTML\n  }, {\n    id: \"f3\",\n    text: reponsesQCM[3].innnerHTML\n  }];\n  for (var i = 0; i < answers.length; i++) {\n    answers[i].text = reponsesQCM[i].innerHTML;\n  }\n  return answers;\n}\nvar score = 0;\nvar nbQCM = 0;\nvar suivant = false;\nvar correctAnswerId;\nvar qcms = [];\nfunction getCorrection(response) {\n  if (suivant) {\n    loadNextQCM();\n  } else {\n    suivant = true;\n    nbQCM += 1;\n    var radios = document.getElementsByClassName('choix');\n    if (response == correctAnswerId) {\n      score += 1;\n    }\n    for (var i = 0, length = radios.length; i < length; i++) {\n      radios[i].disabled = true;\n      if (i == correctAnswerId) {\n        radios[i].style.background = \"#008000\";\n      }\n      if (i == response && response != correctAnswerId) {\n        radios[i].style.background = \"#FF0000\";\n      }\n    }\n  }\n}\nfunction getAnswer() {\n  var radios = document.getElementsByName('choix');\n  for (var i = 0, length = radios.length; i < length; i++) {\n    if (radios[i].checked) {\n      document.getElementById(\"Valider\").innerHTML = \"Suivant\";\n      return i;\n    }\n  }\n}\nfunction shuffle(array) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n  return array;\n}\nfunction recuperationQCM() {\n  // Il faut récupérer tous les qcm\n  let qcms = Array.from(document.getElementsByClassName('qcm')).map(el => el.cloneNode(true));\n  let suppressions = document.getElementsByClassName('qcm');\n  for (let i = 0; i < suppressions.length; i++) {\n    suppressions[i].innerHTML = \"\";\n  }\n  return qcms;\n}\nfunction traitementQCM(qcms) {\n  // Mélanger les qcm\n  qcms = shuffle(qcms);\n\n  // Charger le premier QCM\n  loadNextQCM();\n  var radios = document.getElementsByName('choix');\n  for (var i = 0, length = radios.length; i < length; i++) {\n    radios[i].addEventListener('change', function () {\n      // This function will be executed every time a radio button is selected\n      if (!suivant) {\n        document.getElementById(\"Valider\").innerHTML = \"Répondre\";\n        document.getElementById('Valider').style.display = 'inline';\n      }\n    });\n  }\n  var choixDivs = document.getElementsByClassName('choix');\n  for (var i = 0; i < choixDivs.length; i++) {\n    choixDivs[i].addEventListener('click', function () {\n      // When a .choix div is clicked, select the radio button inside it\n      var radioButton = this.querySelector('input[type=radio]');\n      radioButton.checked = true;\n\n      // Trigger the change event on the radio button\n      var event = new Event('change');\n      radioButton.dispatchEvent(event);\n\n      // Montrer la sélection en la grisant\n      if (!suivant) {\n        for (var j = 0; j < choixDivs.length; j++) {\n          choixDivs[j].style.background = \"none\";\n        }\n        this.style.background = \"#eeeeee\";\n      }\n    });\n  }\n}\nfunction recuperationQCMGroupe() {\n  // Il faut récupérer tous les qcm\n  let qcmgroupes = Array.from(document.getElementsByClassName('groupequiz')).map(el => el.cloneNode(true));\n  // On les supprime du DOM\n  let suppressions = document.getElementsByClassName('groupequiz');\n  for (let i = 0; i < suppressions.length; i++) {\n    suppressions[i].innerHTML = \"\";\n  }\n  let qcms = [];\n  // Dans chaque qcmgroupe il y a des questions et leurs réponses\n  // Pour chaque question on crée un qcm avec sa réponse en premier et trois autres piochées parmi les réponses des autres questions\n  for (let i = 0; i < qcmgroupes.length; i++) {\n    let questions = Array.from(qcmgroupes[i].getElementsByClassName('question')).map(el => el.cloneNode(true));\n    let reponses = Array.from(qcmgroupes[i].getElementsByClassName('reponse')).map(el => el.cloneNode(true));\n    // créer autant de div qu'il y a de questions\n    for (let j = 0; j < questions.length; j++) {\n      let qcm = document.createElement('div');\n      qcm.classList.add('qcm');\n      qcm.appendChild(questions[j]);\n      // Faire une copie de la réponse ajoutée\n      qcm.appendChild(reponses[j].cloneNode(true));\n      let reponsesPossibles = [];\n      for (let k = 0; k < reponses.length; k++) {\n        if (k != j) {\n          reponsesPossibles.push(reponses[k].cloneNode(true));\n        }\n      }\n      reponsesPossibles = shuffle(reponsesPossibles);\n      for (let k = 0; k < 3; k++) {\n        qcm.appendChild(reponsesPossibles[k]);\n      }\n      qcms.push(qcm);\n    }\n  }\n  return qcms;\n}\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  // Il faut s'assurer qu'il y a bien un contexte de quiz\n  if (document.getElementsByClassName('qcm').length != 0 || document.getElementsByClassName('groupequiz').length != 0) {\n    window.addEventListener(\"message\", function (event) {\n      if (event.data == \"figures_created\") {\n        qcms = recuperationQCM();\n        qcms = qcms.concat(recuperationQCMGroupe());\n        traitementQCM(qcms);\n      }\n    }, false);\n    document.getElementById('Valider').addEventListener('click', function () {\n      getCorrection(getAnswer());\n    });\n  }\n});\n\n// Cette fonction remplit le formulaire avec le prochain QCM de la liste\nfunction loadNextQCM() {\n  if (qcms.length > 0) {\n    var nextQCM = qcms.shift();\n    setValider(\"Répondre\");\n    hideValider();\n    disableRadios();\n    var choix = document.getElementsByClassName(\"choix\");\n    hideCorrection(choix);\n    suivant = false;\n    document.getElementById('question').innerHTML = nextQCM.querySelector('.question').innerHTML;\n    var answers = getReponsesPossibles(nextQCM);\n    answers = shuffle(answers);\n    for (var i = 0; i < answers.length; i++) {\n      choix[i].children[1].innerHTML = answers[i].text;\n      if (answers[i].id === \"c\") {\n        correctAnswerId = i;\n      }\n    }\n    // Interactivité des figures\n    // Rechercher les figures\n    var figures = document.querySelectorAll(\".figure\");\n    for (var i = 0; i < figures.length; i++) {\n      (0,_interactif2_js__WEBPACK_IMPORTED_MODULE_0__.addListenerInteractivite)(figures[i]);\n    }\n  } else {\n    score = Math.floor(score / nbQCM * 100);\n    envoyerScore(score);\n    document.getElementById(\"Valider\").style.display = \"none\";\n    document.getElementById(\"formulaire\").style.display = \"none\";\n    let divScore = document.getElementById(\"score\");\n    divScore.style.display = \"block\";\n    let messageFinal = \"<h2>Votre score final est \" + score + \"%.</h2>\";\n    if (score < 100) {\n      messageFinal += '<h2>Ce n\\'était pas évident mais je suis sûr que vous pouvez obtenir 100% de réussite.</h2><button type=\"button\" onclick=\"location.reload();\">Nouvel essai</button>';\n    } else {\n      messageFinal += \"<h2>Félicitations ! Ce n'était pas évident mais vous êtes parvenu au bout !</h2>\";\n    }\n    divScore.innerHTML = messageFinal;\n  }\n}\n\n//# sourceURL=webpack://MyLibrary/./src/js/quiz.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/quiz.js");
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;