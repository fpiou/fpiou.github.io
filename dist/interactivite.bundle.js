/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/class2.js":
/*!**************************!*\
  !*** ./src/js/class2.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cercle: () => (/* binding */ Cercle),\n/* harmony export */   Droite: () => (/* binding */ Droite),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Vecteur: () => (/* binding */ Vecteur)\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nclass Point {\n  constructor(_x, _y) {\n    _defineProperty(this, \"setCoordonneesPoint\", function (point, x, y) {\n      point.x = x;\n      point.y = y;\n    });\n    _defineProperty(this, \"getCoordonneesPoint\", function (point) {\n      return [point.x, point.y];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Point(this.x + vecteur.x, this.y + vecteur.y);\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (point) {\n      return new Point(2 * point.x - this.x, 2 * point.y - this.y);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (point, droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite = new Vecteur(point.x - droite.point1.x, point.y - droite.point1.y);\n      let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n      let symetrique = new Vecteur(point.x - 2 * projection * vecteurNormalUnitaire.x, point.y - 2 * projection * vecteurNormalUnitaire.y);\n      return new Point(symetrique.x, symetrique.y);\n    });\n    _defineProperty(this, \"distance\", function (point1) {\n      return Math.sqrt(Math.pow(this.x - point1.x, 2) + Math.pow(this.y - point1.y, 2));\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Point(centre.x + k * (this.x - centre.x), centre.y + k * (this.y - centre.y));\n    });\n    _defineProperty(this, \"homothetiePoint\", function (centre, point) {\n      let k = centre.distance(point) / centre.distance(this);\n      return this.homothetie(centre, k);\n    });\n    _defineProperty(this, \"angle\", function (point1, point2) {\n      // Retourne l'angle orienté entre les vecteurs (this, point1) et (this, point2)\n      let vecteur1 = new Vecteur(point1.x - this.x, point1.y - this.y);\n      let vecteur2 = new Vecteur(point2.x - this.x, point2.y - this.y);\n      return vecteur1.angle(vecteur2);\n    });\n    _defineProperty(this, \"distancePointDroite\", function (A, B) {\n      return (B.x - A.x) * (this.y - A.y) - (B.y - A.y) * (this.x - A.x);\n    });\n    _defineProperty(this, \"projectionOrthogonale\", function (A, B) {\n      // Projection de this sur la droite (AB)\n      let AB = new Vecteur(B.x - A.x, B.y - A.y);\n      let AC = new Vecteur(this.x - A.x, this.y - A.y);\n      let k = AB.produitScalaire(AC) / (AB.norme() * AB.norme());\n      return new Point(A.x + k * AB.x, A.y + k * AB.y);\n    });\n    _defineProperty(this, \"projectionAngle\", function (A, B, angle) {\n      let AB = new Droite();\n      AB.setCoefficientsDroite2Points(A, B);\n      let u = new Vecteur();\n      u.setCoordonneesVecteur2Points(A, B);\n      let v = u.rotation(angle);\n      let C = this.translation(v);\n      let AC = new Droite();\n      AC.setCoefficientsDroite2Points(this, C);\n      return AB.intersection(AC);\n    });\n    this.x = _x;\n    this.y = _y;\n  }\n  rotation(centre, angle) {\n    let dx = this.x - centre.x;\n    let dy = this.y - centre.y;\n    let rotatedX = centre.x + dx * Math.cos(angle) - dy * Math.sin(angle);\n    let rotatedY = centre.y + dx * Math.sin(angle) + dy * Math.cos(angle);\n    return new Point(rotatedX, rotatedY);\n  }\n}\nclass Vecteur {\n  constructor(_x2, _y2) {\n    _defineProperty(this, \"setCoordonneesVecteur\", function (vecteur, x, y) {\n      vecteur.x = x;\n      vecteur.y = y;\n    });\n    // Méthode pour construire le vecteur à partir de deux points\n    _defineProperty(this, \"setCoordonneesVecteur2Points\", function (point1, point2) {\n      this.x = point2.x - point1.x;\n      this.y = point2.y - point1.y;\n    });\n    _defineProperty(this, \"getCoordonneesVecteur\", function () {\n      return [this.x, this.y];\n    });\n    _defineProperty(this, \"additionVecteur\", function (vecteur) {\n      return new Vecteur(this.x + vecteur.x, this.y + vecteur.y);\n    });\n    _defineProperty(this, \"soustractionVecteur\", function (vecteur) {\n      return new Vecteur(this.x - vecteur.x, this.y - vecteur.y);\n    });\n    _defineProperty(this, \"multiplicationVecteur\", function (k) {\n      return new Vecteur(k * this.x, k * this.y);\n    });\n    _defineProperty(this, \"produitScalaire\", function (vecteur) {\n      return this.x * vecteur.x + this.y * vecteur.y;\n    });\n    _defineProperty(this, \"norme\", function () {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    });\n    _defineProperty(this, \"normalisation\", function () {\n      return new Vecteur(this.x / this.norme(), this.y / this.norme());\n    });\n    _defineProperty(this, \"produitVectoriel\", function (vecteur) {\n      return this.x * vecteur.y - this.y * vecteur.x;\n    });\n    _defineProperty(this, \"angle\", function (vecteur) {\n      // Prévoir un angle signé\n      return Math.atan2(this.produitVectoriel(vecteur), this.produitScalaire(vecteur));\n    });\n    _defineProperty(this, \"projection\", function (vecteur) {\n      return this.produitScalaire(vecteur) / this.norme();\n    });\n    _defineProperty(this, \"projectionOrthogonale\", function (vecteur) {\n      return this.produitVectoriel(vecteur) / this.norme();\n    });\n    _defineProperty(this, \"rotation\", function (angle) {\n      return new Vecteur(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));\n    });\n    this.x = _x2;\n    this.y = _y2;\n  }\n}\nclass Cercle {\n  constructor(_centre, _rayon) {\n    _defineProperty(this, \"setCoordonneesCercle\", function (centre, rayon) {\n      this.centre = centre;\n      this.rayon = rayon;\n    });\n    _defineProperty(this, \"getCoordonneesCercle\", function () {\n      return [this.centre, this.rayon];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Cercle(new Point(2 * centre.x - this.centre.x, 2 * centre.y - this.centre.y), this.rayon);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurCentreDroite = new Vecteur(this.centre.x - droite.point1.x, this.centre.y - droite.point1.y);\n      let projection = vecteurNormalUnitaire.x * vecteurCentreDroite.x + vecteurNormalUnitaire.y * vecteurCentreDroite.y;\n      let symetrique = new Vecteur(this.centre.x - 2 * projection * vecteurNormalUnitaire.x, this.centre.y - 2 * projection * vecteurNormalUnitaire.y);\n      return new Cercle(new Point(symetrique.x, symetrique.y), this.rayon);\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Cercle(new Point((this.centre.x - centre.x) * Math.cos(angle) - (this.centre.y - centre.y) * Math.sin(angle) + centre.x, (this.centre.x - centre.x) * Math.sin(angle) + (this.centre.y - centre.y) * Math.cos(angle) + centre.y), this.rayon);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Cercle(new Point(centre.x + k * (this.centre.x - centre.x), centre.y + k * (this.centre.y - centre.y)), k * this.rayon);\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\n    });\n    this.centre = _centre;\n    this.rayon = _rayon;\n  }\n}\nclass Points {\n  constructor(_points) {\n    _defineProperty(this, \"setCoordonneesPoints\", function (points) {\n      this.points = points;\n    });\n    _defineProperty(this, \"getCoordonneesPoints\", function () {\n      return this.points;\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"rotation\", function (angle, center) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point((this.points[i].x - center.x) * Math.cos(angle) - (this.points[i].y - center.y) * Math.sin(angle) + center.x, (this.points[i].x - center.x) * Math.sin(angle) + (this.points[i].y - center.y) * Math.cos(angle) + center.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"symetriecentrale\", function (centre) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(2 * centre.x - this.points[i].x, 2 * centre.y - this.points[i].y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"symetrieaxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        let vecteurPointDroite = new Vecteur(this.points[i].x - droite.point1.x, this.points[i].y - droite.point1.y);\n        let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n        let symetrique = new Vecteur(this.points[i].x - 2 * projection * vecteurNormalUnitaire.x, this.points[i].y - 2 * projection * vecteurNormalUnitaire.y);\n        points.push(new Point(symetrique.x, symetrique.y));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(centre.x + k * (this.points[i].x - centre.x), centre.y + k * (this.points[i].y - centre.y)));\n      }\n      return new Points(points);\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      let points = [];\n      for (let i = 0; i < this.points.length; i++) {\n        points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\n      }\n      return new Points(points);\n    });\n    this.points = _points;\n  }\n}\nclass Droite {\n  constructor(_a, _b, _c) {\n    _defineProperty(this, \"setCoefficientsDroite\", function (a, b, c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    });\n    _defineProperty(this, \"getCoefficientsDroite\", function () {\n      return [this.a, this.b, this.c];\n    });\n    _defineProperty(this, \"setCoefficientsDroite2Points\", function (point1, point2) {\n      this.a = point2.y - point1.y;\n      this.b = point1.x - point2.x;\n      this.c = point1.y * point2.x - point1.x * point2.y;\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Droite(this.a, this.b, this.c + this.a * vecteur.x + this.b * vecteur.y);\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Droite(this.a * Math.cos(angle) - this.b * Math.sin(angle), this.a * Math.sin(angle) + this.b * Math.cos(angle), this.c + this.a * (centre.y - centre.x * Math.sin(angle)) + this.b * (centre.x * Math.cos(angle) - centre.y));\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Droite(this.a, this.b, this.c + 2 * this.a * centre.x + 2 * this.b * centre.y);\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite = new Vecteur(this.a, this.b);\n      let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\n      let symetrique = new Vecteur(this.a - 2 * projection * vecteurNormalUnitaire.x, this.b - 2 * projection * vecteurNormalUnitaire.y);\n      return new Droite(symetrique.x, symetrique.y, this.c);\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Droite(this.a, this.b, this.c + this.a * (centre.x - k * centre.x) + this.b * (centre.y - k * centre.y));\n    });\n    _defineProperty(this, \"perpendiculaire\", function (point) {\n      return new Droite(-this.b, this.a, this.b * point.x - this.a * point.y);\n    });\n    _defineProperty(this, \"parallele\", function (point) {\n      return new Droite(this.a, this.b, this.c - this.a * point.x + this.b * point.y);\n    });\n    _defineProperty(this, \"intersection\", function (droite) {\n      let x = (this.b * droite.c - droite.b * this.c) / (this.a * droite.b - droite.a * this.b);\n      let y = (this.c * droite.a - droite.c * this.a) / (this.a * droite.b - droite.a * this.b);\n      return new Point(x, y);\n    });\n    this.a = _a;\n    this.b = _b;\n    this.c = _c;\n  }\n}\nclass Segment {\n  constructor(_point, _point2) {\n    _defineProperty(this, \"setCoordonneesSegment\", function (point1, point2) {\n      this.point1 = point1;\n      this.point2 = point2;\n    });\n    _defineProperty(this, \"getCoordonneesSegment\", function () {\n      return [this.point1, this.point2];\n    });\n    _defineProperty(this, \"translation\", function (vecteur) {\n      return new Segment(new Point(this.point1.x + vecteur.x, this.point1.y + vecteur.y), new Point(this.point2.x + vecteur.x, this.point2.y + vecteur.y));\n    });\n    _defineProperty(this, \"rotation\", function (angle, centre) {\n      return new Segment(new Point((this.point1.x - centre.x) * Math.cos(angle) - (this.point1.y - centre.y) * Math.sin(angle) + centre.x, (this.point1.x - centre.x) * Math.sin(angle) + (this.point1.y - centre.y) * Math.cos(angle) + centre.y), new Point((this.point2.x - centre.x) * Math.cos(angle) - (this.point2.y - centre.y) * Math.sin(angle) + centre.x, (this.point2.x - centre.x) * Math.sin(angle) + (this.point2.y - centre.y) * Math.cos(angle) + centre.y));\n    });\n    _defineProperty(this, \"symetrieCentrale\", function (centre) {\n      return new Segment(new Point(2 * centre.x - this.point1.x, 2 * centre.y - this.point1.y), new Point(2 * centre.x - this.point2.x, 2 * centre.y - this.point2.y));\n    });\n    _defineProperty(this, \"symetrieAxiale\", function (droite) {\n      let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\n      let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\n      let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\n      let vecteurPointDroite1 = new Vecteur(this.point1.x - droite.point1.x, this.point1.y - droite.point1.y);\n      let projection1 = vecteurNormalUnitaire.x * vecteurPointDroite1.x + vecteurNormalUnitaire.y * vecteurPointDroite1.y;\n      let symetrique1 = new Vecteur(this.point1.x - 2 * projection1 * vecteurNormalUnitaire.x, this.point1.y - 2 * projection1 * vecteurNormalUnitaire.y);\n      let vecteurPointDroite2 = new Vecteur(this.point2.x - droite.point1.x, this.point2.y - droite.point1.y);\n      let projection2 = vecteurNormalUnitaire.x * vecteurPointDroite2.x + vecteurNormalUnitaire.y * vecteurPointDroite2.y;\n      let symetrique2 = new Vecteur(this.point2.x - 2 * projection2 * vecteurNormalUnitaire.x, this.point2.y - 2 * projection2 * vecteurNormalUnitaire.y);\n      return new Segment(new Point(symetrique1.x, symetrique1.y), new Point(symetrique2.x, symetrique2.y));\n    });\n    _defineProperty(this, \"homothetie\", function (centre, k) {\n      return new Segment(new Point(centre.x + k * (this.point1.x - centre.x), centre.y + k * (this.point1.y - centre.y)), new Point(centre.x + k * (this.point2.x - centre.x), centre.y + k * (this.point2.y - centre.y)));\n    });\n    _defineProperty(this, \"perpendiculaire\", function (point) {\n      let droite = new Droite(this.point1, this.point2);\n      return droite.perpendiculaire(point);\n    });\n    _defineProperty(this, \"parallele\", function (point) {\n      let droite = new Droite(this.point1, this.point2);\n      return droite.parallele(point);\n    });\n    _defineProperty(this, \"milieu\", function () {\n      return new Point((this.point1.x + this.point2.x) / 2, (this.point1.y + this.point2.y) / 2);\n    });\n    _defineProperty(this, \"longueur\", function () {\n      return Math.sqrt(Math.pow(this.point1.x - this.point2.x, 2) + Math.pow(this.point1.y - this.point2.y, 2));\n    });\n    _defineProperty(this, \"angle\", function () {\n      // Retourne l'angle orienté entre le segment et l'axe des abscisses\n      let vecteur = new Vecteur(this.point2.x - this.point1.x, this.point2.y - this.point1.y);\n      return vecteur.angle(new Vecteur(1, 0));\n    });\n    this.point1 = _point;\n    this.point2 = _point2;\n  }\n}\n\n//# sourceURL=webpack://MyLibrary/./src/js/class2.js?");

/***/ }),

/***/ "./src/js/interactif2.js":
/*!*******************************!*\
  !*** ./src/js/interactif2.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListenerInteractivite: () => (/* binding */ addListenerInteractivite),\n/* harmony export */   createFigures: () => (/* binding */ createFigures)\n/* harmony export */ });\n/* harmony import */ var _class2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class2.js */ \"./src/js/class2.js\");\n// Version: 1.0.0\n\n\n// Liste des codages possibles\nvar codagesSegment = [\"M-5,-5 L0,5 M0,-5 L5,5\", \"M-2.5,-5 L2.5,5\", \"M-5,-5 L-1,5 M-1,-5 L3,5 M3,-5 L7,5\", \"M-5,-5 L-2,5 M-2,-5 L1,5 M1,-5 L4,5 M4,-5 L7,5\"];\nvar setUniqueIds = function () {\n  // On récupère toutes les balises de class figure\n  var figures = document.querySelectorAll(\".figure\");\n  // On rend unique les identifiants des éléments constitutifs de la figure\n  for (var i = 0; i < figures.length; i++) {\n    // On récupère l'identifiant de la figure\n    var id = figures[i].id;\n    // on teste si la figure contient un svg\n    if (figures[i].querySelector(\"svg\") != null) {\n      var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*[name]\");\n      // Pour chaque identifiant\n      for (var j = 0; j < ids.length; j++) {\n        // On créé un id pour l'élément\n        ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"name\"));\n\n        // On ajoute également l'identifiant à tous les éléments du linkto\n        if (ids[j].getAttribute(\"linkto\") != null) {\n          var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\n          for (var k = 0; k < linkto.length; k++) {\n            linkto[k] = id + \"-\" + linkto[k];\n          }\n          ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\n        }\n      }\n      // On sélectionne maintenant tous qui n'ont pas la class name\n      var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*:not([name])\");\n      // On ajoute un identifiant s'ils n'ont pas de linkto\n      for (var j = 0; j < ids.length; j++) {\n        if (ids[j].getAttribute(\"linkto\") == null) {\n          ids[j].setAttribute(\"id\", id + \"-\" + j);\n        } else {\n          // On créé un id pour l'élément à partir du linkto\n          // Sauf s'il est de la class label\n          if (!ids[j].classList.contains(\"label\")) {\n            ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"linkto\"));\n          } else {\n            ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"linkto\") + \"-label\");\n          }\n        }\n        // On ajoute également l'identifiant à tous les éléments du linkto\n        if (ids[j].getAttribute(\"linkto\") != null) {\n          var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\n          for (var k = 0; k < linkto.length; k++) {\n            linkto[k] = id + \"-\" + linkto[k];\n          }\n          ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\n        }\n      }\n    }\n  }\n};\nvar addListenerButtonQuadrillage = function (figure) {\n  var quadrillage = figure.querySelector(\"#\" + figure.id + \"-quadrillage\");\n  var bouton = figure.querySelector(\".bouton-quadrillage\");\n  bouton.addEventListener(\"click\", function () {\n    if (quadrillage.style.display == \"none\") {\n      quadrillage.style.display = \"block\";\n    } else {\n      quadrillage.style.display = \"none\";\n    }\n  });\n};\nvar addBoutonQuadrillage = function (figure) {\n  // Tester si la figure a déjà un bouton de la classe bouton-quadrillage\n  if (figure.querySelector(\".bouton-quadrillage\") == null) {\n    // On ajoute un bouton pour afficher/masquer le quadrillage\n    var bouton = document.createElement(\"button\");\n    // Ajouter une classe au bouton\n    bouton.classList.add(\"bouton-quadrillage\");\n    bouton.innerHTML = \"Afficher/masquer le quadrillage\";\n    figure.appendChild(bouton);\n  }\n};\nvar addListenerButtonPleinEcran = function (figure) {\n  var bouton = figure.querySelector(\".bouton-pleinecran\");\n  bouton.addEventListener(\"click\", function () {\n    if (!document.fullscreenElement) {\n      if (figure.requestFullscreen) {\n        figure.requestFullscreen();\n      } else if (figure.webkitRequestFullscreen) {\n        /* Safari */\n        figure.webkitRequestFullscreen();\n      } else if (figure.msRequestFullscreen) {\n        /* IE11 */\n        figure.msRequestFullscreen();\n      }\n    } else {\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.webkitExitFullscreen) {\n        /* Safari */\n        document.webkitExitFullScreen();\n      } else if (document.msExitFullscreen) {\n        /* IE11 */\n        document.msExitFullScreen();\n      }\n    }\n  });\n};\nvar addBoutonPleinEcran = function (figure) {\n  if (figure.querySelector(\".bouton-pleinecran\") == null) {\n    var bouton = document.createElement(\"button\");\n    bouton.classList.add(\"bouton-pleinecran\");\n    bouton.innerHTML = \"Plein écran\";\n    figure.appendChild(bouton);\n  }\n};\nvar addQuadrillage = function (figure) {\n  // On ajoute un quadrillage\n  var quadrillage = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  quadrillage.setAttribute(\"id\", \"quadrillage\");\n  // On récupère les dimensions de la figure avec viewBox\n  var viewBox = figure.querySelector(\"svg\").getAttribute(\"viewBox\").split(\" \");\n  var width = parseFloat(viewBox[2]);\n  var height = parseFloat(viewBox[3]);\n  var xmin = parseFloat(viewBox[0]);\n  var ymin = parseFloat(viewBox[1]);\n  // On calcule le nombres de lignes et de colonnes\n  var nblignes = Math.floor(height / 10);\n  var nbcolonnes = Math.floor(width / 10);\n  // On ajoute les lignes verticales\n  for (i = 0; i < nbcolonnes + 1; i++) {\n    var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    ligne.setAttribute(\"x1\", xmin + i * 10);\n    ligne.setAttribute(\"y1\", ymin);\n    ligne.setAttribute(\"x2\", xmin + i * 10);\n    ligne.setAttribute(\"y2\", ymin + height);\n    ligne.setAttribute(\"stroke\", \"gray\");\n    ligne.setAttribute(\"stroke-width\", \"0.2\");\n    quadrillage.appendChild(ligne);\n  }\n  // On ajoute les lignes horizontales\n  for (var i = 0; i < nblignes + 1; i++) {\n    var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n    ligne.setAttribute(\"x1\", xmin);\n    ligne.setAttribute(\"y1\", ymin + i * 10);\n    ligne.setAttribute(\"x2\", xmin + width);\n    ligne.setAttribute(\"y2\", ymin + i * 10);\n    ligne.setAttribute(\"stroke\", \"gray\");\n    ligne.setAttribute(\"stroke-width\", \"0.2\");\n    quadrillage.appendChild(ligne);\n  }\n  if (!figure.querySelector(\"svg\").classList.contains(\"quadrillage\")) {\n    quadrillage.style.display = \"none\";\n  }\n  quadrillage.style.userSelect = \"none\";\n  quadrillage.style.pointerEvents = \"none\";\n  quadrillage.id = figure.id + \"-quadrillage\";\n  // On place un cadre autour du quadrillage\n  var cadre = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n  cadre.setAttribute(\"x\", xmin);\n  cadre.setAttribute(\"y\", ymin);\n  cadre.setAttribute(\"width\", width);\n  cadre.setAttribute(\"height\", height);\n  cadre.setAttribute(\"fill\", \"lightgray\");\n  cadre.setAttribute(\"fill-opacity\", \"0.2\");\n  // Avec un effet d'ombre\n  figure.querySelector(\"svg\").prepend(quadrillage);\n  figure.querySelector(\"svg\").prepend(cadre);\n};\nvar getLinkto = function (objet) {\n  return objet.getAttribute(\"linkto\").split(\" \");\n};\nvar getElementLinkto = function (objet, n) {\n  return document.getElementById(getLinkto(objet)[n]);\n};\nvar constructLabelPoint = function (point) {\n  if (point.classList.contains(\"labeled\")) {\n    var idfigure = point.id.split(\"-\")[0];\n    var labels = document.getElementById(idfigure).querySelectorAll(\"g.label\");\n    var labelLinkto = Array.from(labels).filter(label => label.getAttribute(\"linkto\") == point.id);\n    var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n    if (labelLinkto.length == 0) {\n      foreignObject.setAttribute(\"x\", \"0\");\n      foreignObject.setAttribute(\"y\", \"0\");\n      foreignObject.setAttribute(\"text-anchor\", \"start\");\n      foreignObject.setAttribute(\"width\", \"20\");\n      foreignObject.setAttribute(\"height\", \"20\");\n      foreignObject.setAttribute(\"style\", point.getAttribute(\"style\"));\n      foreignObject.innerHTML = katex.renderToString(point.getAttribute(\"name\"), {\n        output: \"mathml\"\n      });\n    } else {\n      var label = labelLinkto[0];\n      if (label.hasAttribute(\"x\")) {\n        foreignObject.setAttribute(\"x\", label.getAttribute(\"x\"));\n      } else {\n        foreignObject.setAttribute(\"x\", \"0\");\n      }\n      if (label.hasAttribute(\"y\")) {\n        foreignObject.setAttribute(\"y\", label.getAttribute(\"y\"));\n      } else {\n        foreignObject.setAttribute(\"y\", \"0\");\n      }\n      if (label.hasAttribute(\"width\")) {\n        foreignObject.setAttribute(\"width\", label.getAttribute(\"width\"));\n      } else {\n        foreignObject.setAttribute(\"width\", \"20\");\n      }\n      if (label.hasAttribute(\"height\")) {\n        foreignObject.setAttribute(\"height\", label.getAttribute(\"height\"));\n      } else {\n        foreignObject.setAttribute(\"height\", \"20\");\n      }\n      if (label.hasAttribute(\"text-anchor\")) {\n        foreignObject.setAttribute(\"text-anchor\", label.getAttribute(\"text-anchor\"));\n      } else {\n        foreignObject.setAttribute(\"text-anchor\", \"middle\");\n      }\n      if (label.hasAttribute(\"fill\")) {\n        foreignObject.setAttribute(\"fill\", label.getAttribute(\"fill\"));\n      } else {\n        foreignObject.setAttribute(\"fill\", \"black\");\n      }\n      if (label.hasAttribute(\"stroke\")) {\n        foreignObject.setAttribute(\"stroke\", label.getAttribute(\"stroke\"));\n      } else {\n        foreignObject.setAttribute(\"stroke\", \"stroke\");\n      }\n      foreignObject.setAttribute(\"style\", labelLinkto[0].getAttribute(\"style\"));\n      foreignObject.innerHTML = katex.renderToString(label.innerHTML, {\n        output: \"mathml\"\n      });\n    }\n    foreignObject.style.userSelect = \"none\";\n    point.appendChild(foreignObject);\n  }\n};\nvar constructCrossPoint = function (point) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M-2,-2 L2,2 M-2,2 L2,-2\");\n  path.setAttribute(\"fill\", \"transparent\");\n  path.setAttribute(\"stroke\", \"black\");\n  path.setAttribute(\"class\", \"crosspoint\");\n  path.style.userSelect = \"none\";\n  // Récupérer le style du point\n  var style = point.getAttribute(\"style\");\n  path.setAttribute(\"style\", style);\n  point.appendChild(path);\n};\nvar automaticHideCrossPoint = function (point) {\n  var idfigure = point.id.split(\"-\")[0];\n  getPolygonesFigure(idfigure).forEach(function (polygone) {\n    var linkto = getLinkto(polygone);\n    if (linkto.includes(point.id)) {\n      point.querySelector(\"path.crosspoint\").setAttribute(\"stroke\", \"transparent\");\n    }\n  });\n};\nvar constructHightlightPoint = function (point) {\n  if (point.classList.contains(\"draggable\")) {\n    var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"class\", \"selectionne\");\n    circle.setAttribute(\"cx\", \"0\");\n    circle.setAttribute(\"cy\", \"0\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill-opacity\", \"0.2\");\n    circle.setAttribute(\"r\", \"0\");\n    circle.style.userSelect = \"none\";\n    point.prepend(circle);\n  }\n};\nvar constructSelectPoint = function (point) {\n  if (point.classList.contains(\"draggable\")) {\n    var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    circle.setAttribute(\"class\", \"selectionneur\");\n    circle.setAttribute(\"cx\", \"0\");\n    circle.setAttribute(\"cy\", \"0\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    circle.setAttribute(\"r\", \"4\");\n    point.appendChild(circle);\n  }\n};\nvar getPointsFigure = function (figure) {\n  var points = document.querySelectorAll(\"g.point\");\n  var pointsArray = Array.from(points);\n  return pointsArray.filter(point => point.id.split(\"-\")[0] == figure.id);\n};\nvar initialiserPointTransform = function (point) {\n  var x = 0;\n  var y = 0;\n  if (point.hasAttribute(\"x\")) {\n    x = point.getAttribute(\"x\");\n  }\n  if (point.hasAttribute(\"y\")) {\n    y = point.getAttribute(\"y\");\n  }\n  point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nvar getPolygonesFigure = function (idfigure) {\n  var polygones = document.querySelectorAll(\"g.polygone\");\n  var polygonesArray = Array.from(polygones);\n  return polygonesArray.filter(polygone => polygone.id.split(\"-\")[0] == idfigure);\n};\nvar getVecteursFigure = function (figure) {\n  var vecteurs = document.querySelectorAll(\"g.vecteur\");\n  var vecteursArray = Array.from(vecteurs);\n  return vecteursArray.filter(vecteur => vecteur.id.split(\"-\")[0] == figure.id);\n};\nvar constructHeadVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M-7,-2 L-0,-0 L-7,2\");\n  // Déterminer les coordonnées relatives de B par rappport à A\n  path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\n  path.setAttribute(\"fill\", \"black\");\n  path.setAttribute(\"stroke-width\", \"0.5\");\n  path.classList.add(\"headVecteur\");\n  path.style.userSelect = \"none\";\n  setStroke(vecteur, path);\n  // Ajouter le style du vecteur au path\n  path.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  // Si dans le style il y a un stroke alors on ajoute la même couleur au fill du path\n  if (vecteur.getAttribute(\"style\") != null && vecteur.getAttribute(\"style\").includes(\"stroke\")) {\n    // Récupérer le stroke du style\n    var stroke = vecteur.getAttribute(\"style\").split(\";\").filter(style => style.includes(\"stroke\"))[0];\n    // Récupérer la couleur du stroke\n    var color = stroke.split(\":\")[1];\n    path.setAttribute(\"fill\", color);\n  }\n  vecteur.appendChild(path);\n};\nvar constructLabelVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\n  foreignObject.setAttribute(\"x\", I.x);\n  foreignObject.setAttribute(\"y\", I.y);\n  foreignObject.setAttribute(\"width\", \"20\");\n  foreignObject.setAttribute(\"height\", \"20\");\n  foreignObject.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  // Ajouter le style du vecteur\n  foreignObject.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  foreignObject.innerHTML = katex.renderToString(\"\\\\overrightarrow{\" + vecteur.getAttribute(\"name\") + \"}\", {\n    output: \"mathml\"\n  });\n  foreignObject.style.userSelect = \"none\";\n  vecteur.appendChild(foreignObject);\n};\nvar constructVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\n  setStroke(vecteur, path);\n  vecteur.appendChild(path);\n  constructHeadVecteur(vecteur);\n  // Ajouter le style du vecteur au path\n  path.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\n  if (vecteur.classList.contains(\"labeled\")) {\n    constructLabelVecteur(vecteur);\n  }\n};\nvar initialiserVecteur = function (vecteur) {\n  constructVecteur(vecteur);\n};\nvar initialiserVecteursFigure = function (figure) {\n  getVecteursFigure(figure).forEach(function (vecteur) {\n    initialiserVecteur(vecteur);\n  });\n};\nvar getDroitesFigure = function (figure) {\n  var droites = document.querySelectorAll(\"g.droite\");\n  var droitesArray = Array.from(droites);\n  return droitesArray.filter(droite => droite.id.split(\"-\")[0] == figure.id);\n};\nvar determinerExtremitesDroite = function (droite) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n  AB.setCoordonneesVecteur2Points(A, B);\n  var u = AB.normalisation();\n  var E1 = A.translation(u.multiplicationVecteur(-200));\n  var E2 = A.translation(u.multiplicationVecteur(200));\n  return [E1, E2];\n};\nvar setStroke = function (objet, path) {\n  var stroke = objet.hasAttribute(\"stroke\") ? objet.getAttribute(\"stroke\") : \"black\";\n  path.setAttribute(\"stroke\", stroke);\n  var strokewidth = objet.hasAttribute(\"stroke-width\") ? objet.getAttribute(\"stroke-width\") : \"0.5\";\n  path.setAttribute(\"stroke-width\", strokewidth);\n  // Si c'est un vecteur il faut que le fill soit le même que le srtoke du vecteur\n  if (objet.classList.contains(\"vecteur\")) {\n    path.setAttribute(\"fill\", stroke);\n  }\n};\nvar constructDroite = function (droite) {\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var extremites = determinerExtremitesDroite(droite);\n  var E1 = extremites[0];\n  var E2 = extremites[1];\n  path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\n  setStroke(droite, path);\n  droite.appendChild(path);\n};\nvar initialiserDroite = function (droite) {\n  constructDroite(droite);\n};\nvar initialiserDroitesFigure = function (figure) {\n  getDroitesFigure(figure).forEach(function (droite) {\n    initialiserDroite(droite);\n  });\n};\nvar getDemidroitesFigure = function (figure) {\n  var demidroites = document.querySelectorAll(\"g.demidroite\");\n  var demidroitesArray = Array.from(demidroites);\n  return demidroitesArray.filter(demidroite => demidroite.id.split(\"-\")[0] == figure.id);\n};\nvar constructDemiDroite = function (demidroite) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(demidroite, 0)));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var extremites = determinerExtremitesDroite(demidroite);\n  var E = extremites[1];\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + E.x + \",\" + E.y);\n  setStroke(demidroite, path);\n  demidroite.appendChild(path);\n};\nvar initialiserDemiDroite = function (demidroite) {\n  constructDemiDroite(demidroite);\n};\nvar initialiserDemiDroitesFigure = function (figure) {\n  getDemidroitesFigure(figure).forEach(function (demidroite) {\n    initialiserDemiDroite(demidroite);\n  });\n};\nvar getSegmentsFigure = function (figure) {\n  var segments = document.querySelectorAll(\"g.segment\");\n  var segmentsArray = Array.from(segments);\n  return segmentsArray.filter(segment => segment.id.split(\"-\")[0] == figure.id);\n};\nvar constructCodageSegment = function (segment, codage) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  path.setAttribute(\"fill\", \"transparent\");\n  path.setAttribute(\"stroke\", \"black\");\n  path.setAttribute(\"stroke-width\", \"0.8\");\n  path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + alpha + \")\");\n  path.setAttribute(\"d\", codage);\n  path.style.userSelect = \"none\";\n  path.classList.add(\"codageSegment\");\n  segment.appendChild(path);\n};\nvar isCodageSegment = function (segment) {\n  return segment.classList.contains(\"codage\");\n};\nvar isSegmentLie = function (segment) {\n  // Dans linkto, on a l'id des deux points et éventuellement l'id d'un segment lié par le codage\n  var linkto = getLinkto(segment);\n  return linkto.length == 3;\n};\nvar getSegmentLie = function (segment) {\n  var linkto = getLinkto(segment);\n  return document.getElementById(linkto[2]);\n};\nvar getCodageSegmentLie = function (segment) {\n  var linkto = getLinkto(segment);\n  return getSegmentLie(segment).querySelector(\"path.codageSegment\").getAttribute(\"d\");\n};\nvar listeCodagesFigure = function (objet) {\n  var idfigure = objet.id.split(\"-\")[0];\n  var codages = document.querySelectorAll(\"g.codage\");\n  var codagesArray = Array.from(codages);\n  var codagesFigure = codagesArray.filter(codage => codage.id.split(\"-\")[0] == idfigure).filter(codage => codage.querySelector(\"path.codageSegment\") != null).map(\n  // On récupère l'attribut d\n  codage => codage.querySelector(\"path.codageSegment\").getAttribute(\"d\"));\n  return codagesFigure;\n};\nvar nouveauCodageSegment = function (segment) {\n  var codageExistants = listeCodagesFigure(segment);\n  // On veut un codage qui n'existe pas déjà\n  var i = 0;\n  while (codageExistants.includes(codagesSegment[i])) {\n    i++;\n    if (i == codagesSegment.length) {\n      break;\n    }\n  }\n  if (i < codagesSegment.length) {\n    return codagesSegment[i];\n  } else {\n    // Plus de codages disponibles\n    return \"\";\n  }\n};\nvar constructSegment = function (segment) {\n  var A = getElementLinkto(segment, 0);\n  var B = getElementLinkto(segment, 1);\n  // Construire un élément path\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  // A est l'origine et B l'extrémité du path\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\n  setStroke(segment, path);\n  segment.appendChild(path);\n  if (isCodageSegment(segment)) {\n    if (isSegmentLie(segment)) {\n      constructCodageSegment(segment, getCodageSegmentLie(segment));\n    } else {\n      constructCodageSegment(segment, nouveauCodageSegment(segment));\n    }\n  }\n};\nvar initialiserSegment = function (segment) {\n  constructSegment(segment);\n};\nvar initialiserSegmentsFigure = function (figure) {\n  getSegmentsFigure(figure).forEach(function (segment) {\n    initialiserSegment(segment);\n  });\n};\nvar constructPolygone = function (polygone) {\n  var points = getLinkto(polygone).map(point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))).map(point => [point.x, point.y].join(','));\n  var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n  var d = \"M\" + points.join(\" L\") + \" Z\";\n  path.setAttribute(\"d\", d);\n  setStroke(polygone, path);\n  path.setAttribute(\"style\", polygone.getAttribute(\"style\"));\n  polygone.appendChild(path);\n};\nvar initialiserPolygone = function (polygone) {\n  constructPolygone(polygone);\n};\nvar initialiserPolygonesFigure = function (figure) {\n  getPolygonesFigure(figure.id).forEach(function (polygone) {\n    initialiserPolygone(polygone);\n  });\n};\nvar getGraduationsFigure = function (figure) {\n  var graduations = document.querySelectorAll(\"g.graduation\");\n  var graduationsArray = Array.from(graduations);\n  return graduationsArray.filter(graduation => graduation.id.split(\"-\")[0] == figure.id);\n};\nvar constructGraduation = function (graduation) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(graduation, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(graduation, 1)));\n  var parametres = eval('({' + graduation.getAttribute(\"parametres\") + '})');\n  // Si parametres.vsize n'existe pas alors on prend 4\n  if (parametres.vsize == undefined) {\n    parametres.vsize = 4;\n  }\n  if (parametres.distance == undefined) {\n    parametres.distance = 10;\n  }\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(0, 0);\n  AB.setCoordonneesVecteur2Points(A, B);\n  var u = AB.normalisation();\n  var graduations = [];\n  for (var i = 0; i < parametres.n + 1; i++) {\n    graduations.push(A.translation(u.multiplicationVecteur(i * AB.norme() / parametres.n)));\n  }\n  // Construire les graduations de taille verticale vsize\n  var graduationsSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  var style = graduation.getAttribute(\"style\");\n  graduationsSVG.setAttribute(\"style\", style);\n  for (var i = 0; i < parametres.n + 1; i++) {\n    var graduationSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    // La graduation est pour moitié en dessous et pour moitié au dessus du point\n    // La graduation doit être orientée selon le vecteur u\n    var x1 = graduations[i].x - parametres.vsize / 2 * u.y;\n    var y1 = graduations[i].y + parametres.vsize / 2 * u.x;\n    var x2 = graduations[i].x + parametres.vsize / 2 * u.y;\n    var y2 = graduations[i].y - parametres.vsize / 2 * u.x;\n    graduationSVG.setAttribute(\"d\", \"M\" + x1 + \",\" + y1 + \" L\" + x2 + \",\" + y2);\n    graduationSVG.setAttribute(\"stroke\", \"black\");\n    graduationSVG.setAttribute(\"stroke-width\", \"0.5\");\n    graduationSVG.style.userSelect = \"none\";\n    graduationsSVG.appendChild(graduationSVG);\n  }\n  // On ajoute maintenant les abscisses des graduations si la class abscisses est présente\n  if (graduation.classList.contains(\"abscisses\")) {\n    // Si parametres.nmin n'existe pas alors on prend 0\n    if (parametres.nmin == undefined) {\n      parametres.nmin = 0;\n    }\n    var angle = Math.atan2(u.y, u.x); // Angle de u par rapport à l'axe des abscisses\n\n    var abscissesSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    for (var i = 0; i < parametres.n + 1; i++) {\n      var abscisseSVG = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      var offsetX = 0,\n        offsetY = parametres.distance; // Par défaut, placez les abscisses en dessous\n\n      // Si l'angle est dans le 2ème ou 3ème quadrant, placez les abscisses au-dessus\n      if (angle > Math.PI / 2 && angle < 3 * Math.PI / 2) {\n        offsetY = -parametres.distance;\n      }\n      abscisseSVG.setAttribute(\"x\", graduations[i].x + offsetX);\n      abscisseSVG.setAttribute(\"y\", graduations[i].y + offsetY);\n      abscisseSVG.setAttribute(\"text-anchor\", \"middle\");\n      abscisseSVG.setAttribute(\"font-size\", \"10\");\n      abscisseSVG.setAttribute(\"fill\", \"black\");\n      abscisseSVG.setAttribute(\"stroke\", \"transparent\");\n      abscisseSVG.setAttribute(\"stroke-width\", \"0.5\");\n      abscisseSVG.setAttribute(\"style\", \"user-select:none\");\n      abscisseSVG.setAttribute(\"style\", style);\n      abscisseSVG.innerHTML = (parametres.nmin + i * (parametres.nmax - parametres.nmin) / parametres.n).toFixed(0);\n      graduationsSVG.appendChild(abscisseSVG);\n    }\n  }\n  graduation.appendChild(graduationsSVG);\n};\nvar initialiserGraduation = function (graduation) {\n  constructGraduation(graduation);\n};\nvar initialiserGraduationsFigure = function (figure) {\n  getGraduationsFigure(figure).forEach(function (graduation) {\n    initialiserGraduation(graduation);\n  });\n};\nvar initialiserFigure = function (figure) {\n  addQuadrillage(figure);\n  addBoutonQuadrillage(figure);\n  addBoutonPleinEcran(figure);\n  initialiserPointsFigure(figure);\n  initialiserVecteursFigure(figure);\n  initialiserDroitesFigure(figure);\n  initialiserDemiDroitesFigure(figure);\n  initialiserSegmentsFigure(figure);\n  initialiserPolygonesFigure(figure);\n  initialiserGraduationsFigure(figure);\n};\nvar getCoordonneesPoint = function (point) {\n  var data = point.getAttribute(\"transform\").split(\"translate(\")[1].split(\")\")[0].split(\",\");\n  var x = parseFloat(data[0]);\n  var y = parseFloat(data[1]);\n  return [x, y];\n};\nvar setCoordonneesPoint = function (point, x, y) {\n  point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nvar actualiserCoordonneesPointClassTranslation = function (point) {\n  if (point.classList.contains(\"translation\")) {\n    // M est l'image de P par la translation de vecteur kAB\n    var A = getElementLinkto(point, 0);\n    var B = getElementLinkto(point, 1);\n    var P = getElementLinkto(point, 2);\n    let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\n    let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\n    let u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    u.setCoordonneesVecteur2Points(P1, P2);\n    let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var k = parseFloat(data[0]);\n    let P4 = P3.translation(u.multiplicationVecteur(k));\n    var x4 = P4.x;\n    var y4 = P4.y;\n    setCoordonneesPoint(point, x4, y4);\n  }\n};\nvar actualiserCoordonneesPointClassDilatation = function (point) {\n  if (point.classList.contains(\"dilatation\")) {\n    // H est le projeté de P selon la direction formant un angle alpha avec le vecteur AB\n    // M est l'image de P par l'homothétie de rapport k et de centre H \n    var A = getElementLinkto(point, 0);\n    var B = getElementLinkto(point, 1);\n    var P = getElementLinkto(point, 2);\n    let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\n    let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\n    let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var k = parseFloat(data[1]);\n    var alpha = parseFloat(data[0]) / 180 * Math.PI;\n    var H = P3.projectionAngle(P1, P2, alpha);\n    var M = P3.homothetie(H, k);\n    setCoordonneesPoint(point, M.x, M.y);\n  }\n};\nvar actualiserCoordonneesPointClassRotation = function (point) {\n  if (point.classList.contains(\"rotation\")) {\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n    var data = point.getAttribute(\"data\").split(\" \");\n    var alpha = parseFloat(data[0]) / 180 * Math.PI;\n    if (getLinkto(point).length == 1) {\n      var k = parseFloat(data[1]);\n      var P = A.translation(new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0));\n      var M = P.rotation(A, alpha).homothetie(A, k);\n    } else if (getLinkto(point).length == 2) {\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var k = parseFloat(data[1]);\n      var M = P.rotation(A, alpha).homothetie(A, k);\n    } else if (getLinkto(point).length == 3) {\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n      var k = parseFloat(data[1]);\n      var N = P.rotation(A, alpha).homothetie(A, k);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      u.setCoordonneesVecteur2Points(A, Q);\n      M = N.translation(u);\n    }\n    setCoordonneesPoint(point, M.x, M.y);\n  }\n};\nvar actualiserCoordonneesPointsLies = function (point) {\n  // Récursivité pour atteindre tous les points liés\n  var idPoint = point.getAttribute(\"id\");\n  var points = document.querySelectorAll(\"g.point[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < points.length; i++) {\n    actualiserCoordonneesPoint(points[i]);\n  }\n};\nvar initialiserDataPoint = function (point) {\n  // Si le point subit une tranformation, on initialise l'attribut data si ce n'est pas déjà fait\n  if (point.hasAttribute(\"data\") == false) {\n    if (point.classList.contains(\"translation\")) {\n      point.setAttribute(\"data\", \"1\");\n      point.classList.add(\"transformation\");\n    } else if (point.classList.contains(\"dilatation\")) {\n      point.setAttribute(\"data\", \"90 -1\");\n      point.classList.add(\"transformation\");\n    } else if (point.classList.contains(\"rotation\")) {\n      point.setAttribute(\"data\", \"90 1\");\n      point.classList.add(\"transformation\");\n    }\n  } else {\n    point.classList.add(\"transformation\");\n  }\n};\nvar actualiserLabelVecteur = function (vecteur) {\n  if (vecteur.classList.contains(\"labeled\")) {\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n    var I = AB.milieu();\n    var foreignObject = vecteur.querySelector(\"foreignObject\");\n    foreignObject.setAttribute(\"x\", I.x);\n    foreignObject.setAttribute(\"y\", I.y);\n  }\n};\nvar actualiserVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var path = vecteur.querySelector(\"path\");\n  path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\n  actualiserHeadVecteur(vecteur);\n  actualiserLabelVecteur(vecteur);\n};\nvar actualiserCoordonneesVecteursLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var vecteurs = document.querySelectorAll(\"g.vecteur[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < vecteurs.length; i++) {\n    actualiserVecteur(vecteurs[i]);\n  }\n};\nvar actualiserDroite = function (droite) {\n  var path = droite.querySelector(\"path\");\n  var extremites = determinerExtremitesDroite(droite);\n  var E1 = extremites[0];\n  var E2 = extremites[1];\n  path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\n};\nvar actualiserCoordonneesDroitesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var droites = document.querySelectorAll(\"g.droite[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < droites.length; i++) {\n    actualiserDroite(droites[i]);\n  }\n};\nvar actualiserDemiDroite = function (demidroite) {\n  var path = demidroite.querySelector(\"path\");\n  var extremites = determinerExtremitesDroite(demidroite);\n  var E = extremites[1];\n  var A = getElementLinkto(demidroite, 0);\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + E.x + \",\" + E.y);\n};\nvar actualiserCoordonneesDemiDroitesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var demidroites = document.querySelectorAll(\"g.demidroite[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < demidroites.length; i++) {\n    actualiserDemiDroite(demidroites[i]);\n  }\n};\nvar actualiserCodageSegment = function (segment) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var I = AB.milieu();\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = segment.querySelector(\"path.codageSegment\");\n  path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + -alpha + \")\");\n};\nvar actualiserHeadVecteur = function (vecteur) {\n  var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\n  var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\n  var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\n  var alpha = AB.angle() / Math.PI * 180;\n  var path = vecteur.querySelector(\"path.headVecteur\");\n  path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\n};\nvar actualiserSegment = function (segment) {\n  var A = getElementLinkto(segment, 0);\n  var B = getElementLinkto(segment, 1);\n  var path = segment.querySelector(\"path\");\n  path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\n  if (isCodageSegment(segment)) {\n    actualiserCodageSegment(segment);\n  }\n};\nvar actualiserCoordonneesSegmentsLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var segments = document.querySelectorAll(\"g.segment[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < segments.length; i++) {\n    actualiserSegment(segments[i]);\n  }\n};\nvar actualiserPolygone = function (polygone) {\n  var points = getLinkto(polygone).map(point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))).map(point => [point.x, point.y].join(','));\n  var path = polygone.querySelector(\"path\");\n  var d = \"M\" + points.join(\" L\") + \" Z\";\n  path.setAttribute(\"d\", d);\n};\nvar actualiserCoordonneesPolygonesLies = function (point) {\n  var idPoint = point.getAttribute(\"id\");\n  var polygones = document.querySelectorAll(\"g.polygone[linkto*='\" + idPoint + \"']\");\n  for (var i = 0; i < polygones.length; i++) {\n    actualiserPolygone(polygones[i]);\n  }\n};\nvar actualiserCoordonneesPoint = function (point) {\n  actualiserCoordonneesPointClassTranslation(point);\n  actualiserCoordonneesPointClassDilatation(point);\n  actualiserCoordonneesPointClassRotation(point);\n  actualiserCoordonneesPointsLies(point);\n  actualiserCoordonneesVecteursLies(point);\n  actualiserCoordonneesDroitesLies(point);\n  actualiserCoordonneesDemiDroitesLies(point);\n  actualiserCoordonneesSegmentsLies(point);\n  actualiserCoordonneesPolygonesLies(point);\n};\nvar actualiserPointsFigure = function (figure) {\n  getPointsFigure(figure).forEach(function (point) {\n    actualiserCoordonneesPoint(point);\n  });\n};\nvar setHightlightPointOn = function (point) {\n  d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"orange\");\n  d3.select(point).select(\"circle.selectionne\").attr(\"r\", \"20\");\n};\nvar setHightlightPointOff = function (point) {\n  d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"transparent\");\n  d3.select(point).select(\"circle.selectionne\").attr(\"r\", \"0\");\n};\nvar controlerCoordonneesPoint = function (point, figure) {\n  let x = 0;\n  let y = 0;\n  // Points draggable avec contrainte\n  if (point.classList.contains(\"translation\")) {\n    // On détermine le projeté orthogonal du pointeur de la souris sur la droite parallèle à (AB) et passant par P\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n    var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n    var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n    var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    u.setCoordonneesVecteur2Points(A, B);\n    var Q = P.translation(u);\n    var N = M.projectionOrthogonale(P, Q);\n    x = N.x;\n    y = N.y;\n    // On veut la obtenir le rapport signé de la distance PN sur la distance AB\n    var k = P.distance(N) / A.distance(B);\n    // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\n    var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n    v.setCoordonneesVecteur2Points(P, N);\n    if (u.produitScalaire(v) < 0) {\n      k = -k;\n    }\n    point.setAttribute(\"data\", k.toString());\n  } else if (point.classList.contains(\"rotation\")) {\n    // Tester le nombre de points liés\n    // Si un seul point\n    if (point.getAttribute(\"linkto\").split(\" \").length == 1) {\n      var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n      var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n      var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n      var d = A.distance(M);\n      var N = M.homothetie(A, k / d);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0);\n      var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      v.setCoordonneesVecteur2Points(A, N);\n      var alpha = u.angle(v) / Math.PI * 180;\n      point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n      x = N.x;\n      y = N.y;\n    } else if (point.getAttribute(\"linkto\").split(\" \").length == 2) {\n      if (!point.classList.contains(\"rapport\")) {\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n        var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n        var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n        var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        u.setCoordonneesVecteur2Points(A, B);\n        var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        v.setCoordonneesVecteur2Points(A, M);\n        var alpha = u.angle(v) / Math.PI * 180;\n        point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n        var N = M.homothetie(A, k);\n        x = N.x;\n        y = N.y;\n      } else {\n        // On conserve l'angle mais on change le rapport\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n        var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n        var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        u.setCoordonneesVecteur2Points(A, B);\n        var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n        v.setCoordonneesVecteur2Points(A, M);\n        // Déterminer le signe avec le produit vectoriel\n        var signe = u.produitVectoriel(v) / Math.abs(u.produitVectoriel(v));\n        // On projète M sur l'image de la droite (AB) par la rotation de centre A et d'angle alpha\n        var alpha = parseFloat(point.getAttribute(\"data\").split(\" \")[0]) / 180 * Math.PI;\n        var P1 = B.rotation(A, alpha);\n        var N = M.projectionOrthogonale(A, P1);\n        var k = signe * A.distance(N) / A.distance(B);\n        // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\n        point.setAttribute(\"data\", (alpha / Math.PI * 180).toString() + \" \" + k.toString());\n        x = N.x;\n        y = N.y;\n      }\n    } else if (point.getAttribute(\"linkto\").split(\" \").length == 3) {\n      // Les points sont A, P, Q tels que AQ=AP\n      // Le centre de rotation est maintenant Q mais on veut que le rayon soit toujours AP\n      var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\n      var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\n      var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\n      var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\n      var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\n      var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      u.setCoordonneesVecteur2Points(A, P);\n      var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\n      v.setCoordonneesVecteur2Points(Q, M);\n      var alpha = u.angle(v) / Math.PI * 180;\n      point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\n      var N = M.homothetie(Q, k);\n      x = N.x;\n      y = N.y;\n    }\n  } else {\n    // Il ne faut pas dépasser les limites du cadre\n    // On récupère les dimensions du cadre avec le viewBox\n    var cadre = figure.querySelector(\"svg\");\n    var viewBox = cadre.getAttribute(\"viewBox\").split(\" \");\n    var xmin = parseFloat(viewBox[0]);\n    var ymin = parseFloat(viewBox[1]);\n    var width = parseFloat(viewBox[2]);\n    var height = parseFloat(viewBox[3]);\n    x = Math.min(Math.max(d3.event.x, xmin), xmin + width);\n    y = Math.min(Math.max(d3.event.y, ymin), ymin + height);\n    // Si le quadrillage est affiché, on déplace le point sur le quadrillage\n    if (figure.querySelector(\"#\" + figure.id + \"-quadrillage\").style.display == \"block\") {\n      x = Math.round(x / 10) * 10;\n      y = Math.round(y / 10) * 10;\n    }\n  }\n  return [x, y];\n};\nvar interactivity = function (figure) {\n  d3.selectAll(\"g.point.draggable\").call(d3.drag().on(\"drag\", function () {\n    if (d3.event.x > 0 && d3.event.x < 200 && d3.event.y > 0 && d3.event.y < 200) {\n      setHightlightPointOn(this);\n      setCoordonneesPoint(this, ...controlerCoordonneesPoint(this, figure));\n      actualiserCoordonneesPoint(this);\n    }\n  }).on(\"end\", function () {\n    setHightlightPointOff(this);\n  }));\n};\nvar initialiserPointsFigure = function (figure) {\n  getPointsFigure(figure).filter(point => point.id.split(\"-\")[0] == figure.id).forEach(function (point) {\n    initialiserPointTransform(point);\n    constructLabelPoint(point);\n    constructCrossPoint(point);\n    constructHightlightPoint(point);\n    constructSelectPoint(point);\n    automaticHideCrossPoint(point);\n    initialiserDataPoint(point);\n  });\n};\nvar draggablesAuPremierPlan = function (figure) {\n  var svg = figure.querySelector(\"svg\");\n  var draggable = figure.querySelectorAll(\".draggable\");\n  for (var i = 0; i < draggable.length; i++) {\n    svg.appendChild(draggable[i]);\n  }\n};\nvar addListenerInteractivite = function (figure) {\n  addListenerButtonQuadrillage(figure);\n  addListenerButtonPleinEcran(figure);\n  figure.addEventListener(\"mouseenter\", function () {\n    interactivity(this);\n  });\n};\n\n// Créer les figures\nvar createFigures = function () {\n  setUniqueIds();\n  var figures = document.querySelectorAll(\".figure\");\n  for (var i = 0; i < figures.length; i++) {\n    if (figures[i].querySelector(\"svg\") != null) {\n      initialiserFigure(figures[i]);\n      actualiserPointsFigure(figures[i]);\n      draggablesAuPremierPlan(figures[i]);\n      addListenerInteractivite(figures[i]);\n    }\n  }\n  window.parent.postMessage(\"figures_created\", \"*\");\n};\n\n//# sourceURL=webpack://MyLibrary/./src/js/interactif2.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/interactif2.js");
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;