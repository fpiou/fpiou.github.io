/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/geometrie.ts":
/*!*****************************!*\
  !*** ./src/ts/geometrie.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cercle: () => (/* binding */ Cercle),\n/* harmony export */   Droite: () => (/* binding */ Droite),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Vecteur: () => (/* binding */ Vecteur)\n/* harmony export */ });\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setCoordonneesPoint(point, x, y) {\n        point.x = x;\n        point.y = y;\n    }\n    getCoordonneesPoint(point) {\n        return [point.x, point.y];\n    }\n    translation(vecteur) {\n        return new Point(this.x + vecteur.x, this.y + vecteur.y);\n    }\n    rotation(centre, angle) {\n        let dx = this.x - centre.x;\n        let dy = this.y - centre.y;\n        let rotatedX = centre.x + dx * Math.cos(angle) - dy * Math.sin(angle);\n        let rotatedY = centre.y + dx * Math.sin(angle) + dy * Math.cos(angle);\n        return new Point(rotatedX, rotatedY);\n    }\n    symetrieCentrale(point) {\n        return new Point(2 * point.x - this.x, 2 * point.y - this.y);\n    }\n    symetrieAxiale(d) {\n        let x = (d.b * (d.b * this.x - d.a * this.y) - d.a * d.c) / (d.a * d.a + d.b * d.b);\n        let y = (d.a * (-d.b * this.x + d.a * this.y) - d.b * d.c) / (d.a * d.a + d.b * d.b);\n        return new Point(2 * x - this.x, 2 * y - this.y);\n    }\n    distance(point) {\n        return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2));\n    }\n    homothetie(centre, k) {\n        return new Point(centre.x + k * (this.x - centre.x), centre.y + k * (this.y - centre.y));\n    }\n    homothetiePoint(centre, point) {\n        let k = centre.distance(point) / centre.distance(this);\n        return this.homothetie(centre, k);\n    }\n    angle(point1, point2) {\n        // Retourne l'angle orienté entre les vecteurs (this, point1) et (this, point2)\n        let vecteur1 = new Vecteur(point1.x - this.x, point1.y - this.y);\n        let vecteur2 = new Vecteur(point2.x - this.x, point2.y - this.y);\n        return vecteur1.angle(vecteur2);\n    }\n    distancePointDroite(A, B) {\n        return (B.x - A.x) * (this.y - A.y) - (B.y - A.y) * (this.x - A.x);\n    }\n    projectionOrthogonale(A, B) {\n        // Projection de this sur la droite (AB)\n        let AB = new Vecteur(B.x - A.x, B.y - A.y);\n        let AC = new Vecteur(this.x - A.x, this.y - A.y);\n        let k = AB.produitScalaire(AC) / (AB.norme() * AB.norme());\n        return new Point(A.x + k * AB.x, A.y + k * AB.y);\n    }\n    projectionAngle(A, B, angle) {\n        let AB = new Droite(0, 0, 0);\n        AB.setCoefficientsDroite2Points(A, B);\n        let u = new Vecteur(0, 0);\n        u.setCoordonneesVecteur2Points(A, B);\n        let v = u.rotation(angle);\n        let C = this.translation(v);\n        let AC = new Droite(0, 0, 0);\n        AC.setCoefficientsDroite2Points(this, C);\n        return AB.intersection(AC);\n    }\n}\nclass Vecteur {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setCoordonneesVecteur(vecteur, x, y) {\n        vecteur.x = x;\n        vecteur.y = y;\n    }\n    // Méthode pour construire le vecteur à partir de deux points\n    setCoordonneesVecteur2Points(point1, point2) {\n        this.x = point2.x - point1.x;\n        this.y = point2.y - point1.y;\n    }\n    getCoordonneesVecteur() {\n        return [this.x, this.y];\n    }\n    additionVecteur(vecteur) {\n        return new Vecteur(this.x + vecteur.x, this.y + vecteur.y);\n    }\n    soustractionVecteur(vecteur) {\n        return new Vecteur(this.x - vecteur.x, this.y - vecteur.y);\n    }\n    multiplicationVecteur(k) {\n        return new Vecteur(k * this.x, k * this.y);\n    }\n    produitScalaire(vecteur) {\n        return this.x * vecteur.x + this.y * vecteur.y;\n    }\n    norme() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    normalisation() {\n        return new Vecteur(this.x / this.norme(), this.y / this.norme());\n    }\n    produitVectoriel(vecteur) {\n        return this.x * vecteur.y - this.y * vecteur.x;\n    }\n    angle(vecteur) {\n        // Prévoir un angle signé\n        return Math.atan2(this.produitVectoriel(vecteur), this.produitScalaire(vecteur));\n    }\n    projection(vecteur) {\n        return this.produitScalaire(vecteur) / this.norme();\n    }\n    projectionOrthogonale(vecteur) {\n        return this.produitVectoriel(vecteur) / this.norme();\n    }\n    rotation(angle) {\n        return new Vecteur(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));\n    }\n    oppose() {\n        return new Vecteur(-this.x, -this.y);\n    }\n}\nclass Cercle {\n    constructor(centre, rayon) {\n        this.centre = centre;\n        this.rayon = rayon;\n    }\n    setCoordonneesCercle(centre, rayon) {\n        this.centre = centre;\n        this.rayon = rayon;\n    }\n    getCoordonneesCercle() {\n        return [this.centre, this.rayon];\n    }\n    symetrieCentrale(centre) {\n        return new Cercle(new Point(2 * centre.x - this.centre.x, 2 * centre.y - this.centre.y), this.rayon);\n    }\n    symetrieAxiale(droite) {\n        let x = (droite.b * (droite.b * this.centre.x - droite.a * this.centre.y) - droite.a * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        let y = (droite.a * (-droite.b * this.centre.x + droite.a * this.centre.y) - droite.b * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        return new Cercle(new Point(2 * x - this.centre.x, 2 * y - this.centre.y), this.rayon);\n    }\n    rotation(angle, centre) {\n        return new Cercle(new Point((this.centre.x - centre.x) * Math.cos(angle) - (this.centre.y - centre.y) * Math.sin(angle) + centre.x, (this.centre.x - centre.x) * Math.sin(angle) + (this.centre.y - centre.y) * Math.cos(angle) + centre.y), this.rayon);\n    }\n    homothetie(centre, k) {\n        return new Cercle(new Point(centre.x + k * (this.centre.x - centre.x), centre.y + k * (this.centre.y - centre.y)), k * this.rayon);\n    }\n    translation(vecteur) {\n        return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\n    }\n}\nclass Droite {\n    constructor(a, b, c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    setCoefficientsDroite(a, b, c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    getCoefficientsDroite() {\n        return [this.a, this.b, this.c];\n    }\n    getVecteurDirecteur() {\n        return new Vecteur(this.a, this.b);\n    }\n    getVecteurNormal() {\n        return new Vecteur(-this.b, this.a);\n    }\n    getVecteurNormalUnitaire() {\n        return new Vecteur(-this.b / Math.sqrt(this.a * this.a + this.b * this.b), this.a / Math.sqrt(this.a * this.a + this.b * this.b));\n    }\n    setCoefficientsDroite2Points(point1, point2) {\n        this.a = point2.y - point1.y;\n        this.b = point1.x - point2.x;\n        this.c = point1.y * point2.x - point1.x * point2.y;\n    }\n    translation(vecteur) {\n        return new Droite(this.a, this.b, this.c + this.a * vecteur.x + this.b * vecteur.y);\n    }\n    rotation(angle, centre) {\n        return new Droite(this.a * Math.cos(angle) - this.b * Math.sin(angle), this.a * Math.sin(angle) + this.b * Math.cos(angle), this.c + this.a * (centre.y - centre.x * Math.sin(angle)) + this.b * (centre.x * Math.cos(angle) - centre.y));\n    }\n    symetrieCentrale(centre) {\n        return new Droite(this.a, this.b, this.c + 2 * this.a * centre.x + 2 * this.b * centre.y);\n    }\n    symetrieAxiale(d) {\n        // Choisissons deux points sur la droite this\n        let x1 = 0;\n        let y1 = (-this.c - this.a * x1) / this.b;\n        let x2 = 1;\n        let y2 = (-this.c - this.a * x2) / this.b;\n        // Trouvons leurs symétriques par rapport à d\n        let x1Prime = x1 - 2 * d.a * (d.a * x1 + d.b * y1 + d.c) / (d.a ** 2 + d.b ** 2);\n        let y1Prime = y1 - 2 * d.b * (d.a * x1 + d.b * y1 + d.c) / (d.a ** 2 + d.b ** 2);\n        let x2Prime = x2 - 2 * d.a * (d.a * x2 + d.b * y2 + d.c) / (d.a ** 2 + d.b ** 2);\n        let y2Prime = y2 - 2 * d.b * (d.a * x2 + d.b * y2 + d.c) / (d.a ** 2 + d.b ** 2);\n        // Trouvons l'équation de la droite passant par P1' et P2'\n        let aPrime = y2Prime - y1Prime;\n        let bPrime = x1Prime - x2Prime;\n        let cPrime = x2Prime * y1Prime - x1Prime * y2Prime;\n        return new Droite(aPrime, bPrime, cPrime);\n    }\n    homothetie(centre, k) {\n        return new Droite(this.a, this.b, this.c + this.a * (centre.x - k * centre.x) + this.b * (centre.y - k * centre.y));\n    }\n    perpendiculaire(point) {\n        return new Droite(-this.b, this.a, this.b * point.x - this.a * point.y);\n    }\n    parallele(point) {\n        return new Droite(this.a, this.b, this.c - this.a * point.x + this.b * point.y);\n    }\n    intersection(droite) {\n        let x = (this.b * droite.c - droite.b * this.c) / (this.a * droite.b - droite.a * this.b);\n        let y = (this.c * droite.a - droite.c * this.a) / (this.a * droite.b - droite.a * this.b);\n        return new Point(x, y);\n    }\n}\nclass Points {\n    constructor(points) {\n        this.points = points;\n    }\n    setCoordonneesPoints(points) {\n        this.points = points;\n    }\n    getCoordonneesPoints() {\n        return this.points;\n    }\n    rotation(angle, centre) {\n        let points = [];\n        for (let i = 0; i < this.points.length; i++) {\n            points.push(new Point((this.points[i].x - centre.x) * Math.cos(angle) - (this.points[i].y - centre.y) * Math.sin(angle) + centre.x, (this.points[i].x - centre.x) * Math.sin(angle) + (this.points[i].y - centre.y) * Math.cos(angle) + centre.y));\n        }\n        return new Points(points);\n    }\n    symetriecentrale(centre) {\n        let points = [];\n        for (let i = 0; i < this.points.length; i++) {\n            points.push(new Point(2 * centre.x - this.points[i].x, 2 * centre.y - this.points[i].y));\n        }\n        return new Points(points);\n    }\n    symetrieaxiale(droite) {\n        let points = [];\n        for (let i = 0; i < this.points.length; i++) {\n            let x = (droite.b * (droite.b * this.points[i].x - droite.a * this.points[i].y) - droite.a * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n            let y = (droite.a * (-droite.b * this.points[i].x + droite.a * this.points[i].y) - droite.b * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n            points.push(new Point(2 * x - this.points[i].x, 2 * y - this.points[i].y));\n        }\n        return new Points(points);\n    }\n    homothetie(centre, k) {\n        let points = [];\n        for (let i = 0; i < this.points.length; i++) {\n            points.push(new Point(centre.x + k * (this.points[i].x - centre.x), centre.y + k * (this.points[i].y - centre.y)));\n        }\n        return new Points(points);\n    }\n    translation(vecteur) {\n        let points = [];\n        for (let i = 0; i < this.points.length; i++) {\n            points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\n        }\n        return new Points(points);\n    }\n}\nclass Segment {\n    constructor(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n    }\n    setCoordonneesSegment(point1, point2) {\n        this.point1 = point1;\n        this.point2 = point2;\n    }\n    getCoordonneesSegment() {\n        return [this.point1, this.point2];\n    }\n    translation(vecteur) {\n        return new Segment(new Point(this.point1.x + vecteur.x, this.point1.y + vecteur.y), new Point(this.point2.x + vecteur.x, this.point2.y + vecteur.y));\n    }\n    rotation(angle, centre) {\n        return new Segment(new Point((this.point1.x - centre.x) * Math.cos(angle) - (this.point1.y - centre.y) * Math.sin(angle) + centre.x, (this.point1.x - centre.x) * Math.sin(angle) + (this.point1.y - centre.y) * Math.cos(angle) + centre.y), new Point((this.point2.x - centre.x) * Math.cos(angle) - (this.point2.y - centre.y) * Math.sin(angle) + centre.x, (this.point2.x - centre.x) * Math.sin(angle) + (this.point2.y - centre.y) * Math.cos(angle) + centre.y));\n    }\n    symetrieCentrale(centre) {\n        return new Segment(new Point(2 * centre.x - this.point1.x, 2 * centre.y - this.point1.y), new Point(2 * centre.x - this.point2.x, 2 * centre.y - this.point2.y));\n    }\n    symetrieAxiale(droite) {\n        let x1 = (droite.b * (droite.b * this.point1.x - droite.a * this.point1.y) - droite.a * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        let y1 = (droite.a * (-droite.b * this.point1.x + droite.a * this.point1.y) - droite.b * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        let x2 = (droite.b * (droite.b * this.point2.x - droite.a * this.point2.y) - droite.a * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        let y2 = (droite.a * (-droite.b * this.point2.x + droite.a * this.point2.y) - droite.b * droite.c) / (droite.a * droite.a + droite.b * droite.b);\n        return new Segment(new Point(2 * x1 - this.point1.x, 2 * y1 - this.point1.y), new Point(2 * x2 - this.point2.x, 2 * y2 - this.point2.y));\n    }\n    homothetie(centre, k) {\n        return new Segment(new Point(centre.x + k * (this.point1.x - centre.x), centre.y + k * (this.point1.y - centre.y)), new Point(centre.x + k * (this.point2.x - centre.x), centre.y + k * (this.point2.y - centre.y)));\n    }\n    perpendiculaire(point) {\n        let droite = new Droite(0, 0, 0);\n        droite.setCoefficientsDroite2Points(this.point1, this.point2);\n        return droite.perpendiculaire(point);\n    }\n    parallele(point) {\n        let droite = new Droite(0, 0, 0);\n        droite.setCoefficientsDroite2Points(this.point1, this.point2);\n        return droite.parallele(point);\n    }\n    milieu() {\n        return new Point((this.point1.x + this.point2.x) / 2, (this.point1.y + this.point2.y) / 2);\n    }\n    longueur() {\n        return Math.sqrt(Math.pow(this.point1.x - this.point2.x, 2) + Math.pow(this.point1.y - this.point2.y, 2));\n    }\n    angle() {\n        // Retourne l'angle orienté entre le segment et l'axe des abscisses\n        let vecteur = new Vecteur(this.point2.x - this.point1.x, this.point2.y - this.point1.y);\n        return vecteur.angle(new Vecteur(1, 0));\n    }\n}\nwindow.Point = Point;\nwindow.Vecteur = Vecteur;\nwindow.Cercle = Cercle;\nwindow.Droite = Droite;\nwindow.Points = Points;\nwindow.Segment = Segment;\n\n\n//# sourceURL=webpack://MyLibrary/./src/ts/geometrie.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/geometrie.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;