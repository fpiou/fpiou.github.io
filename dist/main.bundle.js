/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var MyLibrary;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/class2.js":
/*!**************************!*\
  !*** ./src/js/class2.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cercle: () => (/* binding */ Cercle),\n/* harmony export */   Droite: () => (/* binding */ Droite),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Vecteur: () => (/* binding */ Vecteur)\n/* harmony export */ });\nclass Point {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    setCoordonneesPoint = function (point, x, y) {\r\n        point.x = x;\r\n        point.y = y;\r\n    }\r\n    getCoordonneesPoint = function (point) {\r\n        return [point.x, point.y];\r\n    }\r\n    translation = function (vecteur) {\r\n        return new Point(this.x + vecteur.x, this.y + vecteur.y);\r\n    }\r\n    rotation(centre, angle) {\r\n        let dx = this.x - centre.x;\r\n        let dy = this.y - centre.y;\r\n      \r\n        let rotatedX = centre.x + dx * Math.cos(angle) - dy * Math.sin(angle);\r\n        let rotatedY = centre.y + dx * Math.sin(angle) + dy * Math.cos(angle);\r\n      \r\n        return new Point(rotatedX, rotatedY);\r\n    }\r\n    symetrieCentrale = function (point) {\r\n        return new Point(2 * point.x - this.x, 2 * point.y - this.y);\r\n    }\r\n    symetrieAxiale = function (point, droite) {\r\n        let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\r\n        let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\r\n        let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\r\n        let vecteurPointDroite = new Vecteur(point.x - droite.point1.x, point.y - droite.point1.y);\r\n        let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\r\n        let symetrique = new Vecteur(point.x - 2 * projection * vecteurNormalUnitaire.x, point.y - 2 * projection * vecteurNormalUnitaire.y);\r\n        return new Point(symetrique.x, symetrique.y);\r\n    }\r\n    distance = function (point1) {\r\n        return Math.sqrt(Math.pow(this.x - point1.x, 2) + Math.pow(this.y - point1.y, 2));\r\n    }\r\n    homothetie = function (centre,k) {\r\n        return new Point(centre.x + k * (this.x - centre.x), centre.y + k * (this.y - centre.y));\r\n    }\r\n    homothetiePoint = function (centre, point) {\r\n        let k = centre.distance(point) / centre.distance(this);\r\n        return this.homothetie(centre, k);\r\n    }\r\n    angle = function (point1, point2) {\r\n        // Retourne l'angle orienté entre les vecteurs (this, point1) et (this, point2)\r\n        let vecteur1 = new Vecteur(point1.x - this.x, point1.y - this.y);\r\n        let vecteur2 = new Vecteur(point2.x - this.x, point2.y - this.y);\r\n        return vecteur1.angle(vecteur2);\r\n    }\r\n    distancePointDroite = function (A,B) {\r\n        return (B.x - A.x)*(this.y - A.y) - (B.y - A.y)*(this.x - A.x);\r\n    }\r\n    projectionOrthogonale = function (A,B) {\r\n        // Projection de this sur la droite (AB)\r\n        let AB = new Vecteur(B.x-A.x,B.y-A.y);\r\n        let AC = new Vecteur(this.x-A.x,this.y-A.y);\r\n        let k = AB.produitScalaire(AC)/(AB.norme()*AB.norme());\r\n        return new Point(A.x+k*AB.x, A.y+k*AB.y);\r\n    }\r\n    projectionAngle = function (A,B,angle) {\r\n        let AB = new Droite()\r\n        AB.setCoefficientsDroite2Points(A,B);\r\n        let u = new Vecteur()\r\n        u.setCoordonneesVecteur2Points(A,B)\r\n        let v = u.rotation(angle);\r\n        let C = this.translation(v)\r\n        let AC = new Droite()\r\n        AC.setCoefficientsDroite2Points(this,C)\r\n        return AB.intersection(AC)\r\n    }\r\n}\r\nclass Vecteur {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    setCoordonneesVecteur = function (vecteur, x, y) {\r\n        vecteur.x = x;\r\n        vecteur.y = y;\r\n    }\r\n    // Méthode pour construire le vecteur à partir de deux points\r\n    setCoordonneesVecteur2Points = function (point1, point2) {\r\n        this.x = point2.x - point1.x;\r\n        this.y = point2.y - point1.y;\r\n    }\r\n    getCoordonneesVecteur = function () {\r\n        return [this.x, this.y];\r\n    }\r\n    additionVecteur = function (vecteur) {\r\n        return new Vecteur(this.x + vecteur.x, this.y + vecteur.y);\r\n    }\r\n    soustractionVecteur = function (vecteur) {\r\n        return new Vecteur(this.x - vecteur.x, this.y - vecteur.y);\r\n    }\r\n    multiplicationVecteur = function (k) {\r\n        return new Vecteur(k * this.x, k * this.y);\r\n    }\r\n    produitScalaire = function (vecteur) {\r\n        return this.x * vecteur.x + this.y * vecteur.y;\r\n    }\r\n    norme = function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n    normalisation = function () {\r\n        return new Vecteur(this.x / this.norme(), this.y / this.norme());\r\n    }\r\n    produitVectoriel = function (vecteur) {\r\n        return this.x * vecteur.y - this.y * vecteur.x;\r\n    }\r\n    angle = function (vecteur) {\r\n        // Prévoir un angle signé\r\n        return Math.atan2(this.produitVectoriel(vecteur), this.produitScalaire(vecteur));\r\n    }\r\n    projection = function (vecteur) {\r\n        return this.produitScalaire(vecteur) / this.norme();\r\n    }\r\n    projectionOrthogonale = function (vecteur) {\r\n        return this.produitVectoriel(vecteur) / this.norme();\r\n    }\r\n    rotation = function (angle) {\r\n        return new Vecteur(this.x * Math.cos(angle) - this.y * Math.sin(angle), this.x * Math.sin(angle) + this.y * Math.cos(angle));\r\n    }\r\n}\r\nclass Cercle {\r\n    constructor(centre, rayon) {\r\n        this.centre = centre;\r\n        this.rayon = rayon;\r\n    }\r\n    setCoordonneesCercle = function (centre, rayon) {\r\n        this.centre = centre;\r\n        this.rayon = rayon;\r\n    }\r\n    getCoordonneesCercle = function () {\r\n        return [this.centre, this.rayon];\r\n    }\r\n    translation = function (vecteur) {\r\n        return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\r\n    }\r\n    symetrieCentrale =  function (centre) {\r\n        return new Cercle(new Point(2 * centre.x - this.centre.x, 2 * centre.y - this.centre.y), this.rayon);\r\n    }\r\n    symetrieAxiale = function (droite) {\r\n        let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\r\n        let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\r\n        let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\r\n        let vecteurCentreDroite = new Vecteur(this.centre.x - droite.point1.x, this.centre.y - droite.point1.y);\r\n        let projection = vecteurNormalUnitaire.x * vecteurCentreDroite.x + vecteurNormalUnitaire.y * vecteurCentreDroite.y;\r\n        let symetrique = new Vecteur(this.centre.x - 2 * projection * vecteurNormalUnitaire.x, this.centre.y - 2 * projection * vecteurNormalUnitaire.y);\r\n        return new Cercle(new Point(symetrique.x, symetrique.y), this.rayon);\r\n    }\r\n    rotation = function (angle, centre) {\r\n        return new Cercle(new Point((this.centre.x-centre.x) * Math.cos(angle) - (this.centre.y-centre.y) * Math.sin(angle)+centre.x, (this.centre.x-centre.x) * Math.sin(angle) + (this.centre.y-centre.y) * Math.cos(angle)+centre.y), this.rayon);\r\n    }\r\n    homothetie = function (centre,k) {\r\n        return new Cercle(new Point(centre.x + k * (this.centre.x - centre.x), centre.y + k * (this.centre.y - centre.y)), k * this.rayon);\r\n    }\r\n    translation = function (vecteur) {\r\n        return new Cercle(new Point(this.centre.x + vecteur.x, this.centre.y + vecteur.y), this.rayon);\r\n    }\r\n}\r\nclass Points {\r\n    constructor(points) {\r\n        this.points = points;\r\n    }\r\n    setCoordonneesPoints = function (points) {\r\n        this.points = points;\r\n    }\r\n    getCoordonneesPoints = function () {\r\n        return this.points;\r\n    }\r\n    translation = function (vecteur) {\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\r\n        }\r\n        return new Points(points);\r\n    }\r\n    rotation = function (angle, center) {\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            points.push(new Point((this.points[i].x-center.x) * Math.cos(angle) - (this.points[i].y-center.y) * Math.sin(angle)+center.x, (this.points[i].x-center.x) * Math.sin(angle) + (this.points[i].y-center.y) * Math.cos(angle)+center.y));\r\n        }\r\n        return new Points(points);\r\n    }\r\n    symetriecentrale = function (centre) {\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            points.push(new Point(2 * centre.x - this.points[i].x, 2 * centre.y - this.points[i].y));\r\n        }\r\n        return new Points(points);\r\n    }\r\n    symetrieaxiale = function (droite) {\r\n        let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\r\n        let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\r\n        let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            let vecteurPointDroite = new Vecteur(this.points[i].x - droite.point1.x, this.points[i].y - droite.point1.y);\r\n            let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\r\n            let symetrique = new Vecteur(this.points[i].x - 2 * projection * vecteurNormalUnitaire.x, this.points[i].y - 2 * projection * vecteurNormalUnitaire.y);\r\n            points.push(new Point(symetrique.x, symetrique.y));\r\n        }\r\n        return new Points(points);\r\n    }\r\n    homothetie = function (centre,k) {\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            points.push(new Point(centre.x + k * (this.points[i].x - centre.x), centre.y + k * (this.points[i].y - centre.y)));\r\n        }\r\n        return new Points(points);\r\n    }\r\n    translation = function (vecteur) {\r\n        let points = [];\r\n        for (let i = 0; i < this.points.length; i++) {\r\n            points.push(new Point(this.points[i].x + vecteur.x, this.points[i].y + vecteur.y));\r\n        }\r\n        return new Points(points);\r\n    }\r\n}\r\nclass Droite {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    setCoefficientsDroite = function (a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    getCoefficientsDroite = function () {\r\n        return [this.a, this.b, this.c];\r\n    }\r\n    setCoefficientsDroite2Points = function (point1, point2) {\r\n        this.a = point2.y - point1.y;\r\n        this.b = point1.x - point2.x;\r\n        this.c = point1.y * point2.x - point1.x * point2.y;\r\n    }\r\n    translation = function (vecteur) {\r\n        return new Droite(this.a, this.b, this.c + this.a * vecteur.x + this.b * vecteur.y);\r\n    }\r\n    rotation = function (angle, centre) {\r\n        return new Droite(this.a * Math.cos(angle) - this.b * Math.sin(angle), this.a * Math.sin(angle) + this.b * Math.cos(angle), this.c + this.a * (centre.y - centre.x * Math.sin(angle)) + this.b * (centre.x * Math.cos(angle) - centre.y));\r\n    }\r\n    symetrieCentrale = function (centre) {\r\n        return new Droite(this.a, this.b, this.c + 2 * this.a * centre.x + 2 * this.b * centre.y);\r\n    }\r\n    symetrieAxiale = function (droite) {\r\n        let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\r\n        let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\r\n        let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\r\n        let vecteurPointDroite = new Vecteur(this.a, this.b);\r\n        let projection = vecteurNormalUnitaire.x * vecteurPointDroite.x + vecteurNormalUnitaire.y * vecteurPointDroite.y;\r\n        let symetrique = new Vecteur(this.a - 2 * projection * vecteurNormalUnitaire.x, this.b - 2 * projection * vecteurNormalUnitaire.y);\r\n        return new Droite(symetrique.x, symetrique.y, this.c);\r\n    }\r\n    homothetie = function (centre,k) {\r\n        return new Droite(this.a, this.b, this.c + this.a * (centre.x - k * centre.x) + this.b * (centre.y - k * centre.y));\r\n    }\r\n    perpendiculaire = function (point) {\r\n        return new Droite(-this.b, this.a, this.b * point.x - this.a * point.y);\r\n    }\r\n    parallele = function (point) {\r\n        return new Droite(this.a, this.b, this.c - this.a * point.x + this.b * point.y);\r\n    }\r\n    intersection = function (droite) {\r\n        let x = (this.b * droite.c - droite.b * this.c) / (this.a * droite.b - droite.a * this.b);\r\n        let y = (this.c * droite.a - droite.c * this.a) / (this.a * droite.b - droite.a * this.b);\r\n        return new Point(x, y);\r\n    }\r\n}\r\nclass Segment {\r\n    constructor(point1, point2) {\r\n        this.point1 = point1;\r\n        this.point2 = point2;\r\n    }\r\n    setCoordonneesSegment = function (point1, point2) {\r\n        this.point1 = point1;\r\n        this.point2 = point2;\r\n    }\r\n    getCoordonneesSegment = function () {\r\n        return [this.point1, this.point2];\r\n    }\r\n    translation = function (vecteur) {\r\n        return new Segment(new Point(this.point1.x + vecteur.x, this.point1.y + vecteur.y), new Point(this.point2.x + vecteur.x, this.point2.y + vecteur.y));\r\n    }\r\n    rotation = function (angle, centre) {\r\n        return new Segment(new Point((this.point1.x-centre.x) * Math.cos(angle) - (this.point1.y-centre.y) * Math.sin(angle)+centre.x, (this.point1.x-centre.x) * Math.sin(angle) + (this.point1.y-centre.y) * Math.cos(angle)+centre.y), new Point((this.point2.x-centre.x) * Math.cos(angle) - (this.point2.y-centre.y) * Math.sin(angle)+centre.x, (this.point2.x-centre.x) * Math.sin(angle) + (this.point2.y-centre.y) * Math.cos(angle)+centre.y));\r\n    }\r\n    symetrieCentrale = function (centre) {\r\n        return new Segment(new Point(2 * centre.x - this.point1.x, 2 * centre.y - this.point1.y), new Point(2 * centre.x - this.point2.x, 2 * centre.y - this.point2.y));\r\n    }\r\n    symetrieAxiale = function (droite) {\r\n        let vecteur = new Vecteur(droite.point2.x - droite.point1.x, droite.point2.y - droite.point1.y);\r\n        let vecteurNormal = new Vecteur(-vecteur.y, vecteur.x);\r\n        let vecteurNormalUnitaire = new Vecteur(vecteurNormal.x / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y), vecteurNormal.y / Math.sqrt(vecteurNormal.x * vecteurNormal.x + vecteurNormal.y * vecteurNormal.y));\r\n        let vecteurPointDroite1 = new Vecteur(this.point1.x - droite.point1.x, this.point1.y - droite.point1.y);\r\n        let projection1 = vecteurNormalUnitaire.x * vecteurPointDroite1.x + vecteurNormalUnitaire.y * vecteurPointDroite1.y;\r\n        let symetrique1 = new Vecteur(this.point1.x - 2 * projection1 * vecteurNormalUnitaire.x, this.point1.y - 2 * projection1 * vecteurNormalUnitaire.y);\r\n        let vecteurPointDroite2 = new Vecteur(this.point2.x - droite.point1.x, this.point2.y - droite.point1.y);\r\n        let projection2 = vecteurNormalUnitaire.x * vecteurPointDroite2.x + vecteurNormalUnitaire.y * vecteurPointDroite2.y;\r\n        let symetrique2 = new Vecteur(this.point2.x - 2 * projection2 * vecteurNormalUnitaire.x, this.point2.y - 2 * projection2 * vecteurNormalUnitaire.y);\r\n        return new Segment(new Point(symetrique1.x, symetrique1.y), new Point(symetrique2.x, symetrique2.y));\r\n    }\r\n    homothetie = function (centre,k) {\r\n        return new Segment(new Point(centre.x + k * (this.point1.x - centre.x), centre.y + k * (this.point1.y - centre.y)), new Point(centre.x + k * (this.point2.x - centre.x), centre.y + k * (this.point2.y - centre.y)));\r\n    }\r\n    perpendiculaire = function (point) {\r\n        let droite = new Droite(this.point1, this.point2);\r\n        return droite.perpendiculaire(point);\r\n    }\r\n    parallele = function (point) {\r\n        let droite = new Droite(this.point1, this.point2);\r\n        return droite.parallele(point);\r\n    }\r\n    milieu = function () {\r\n        return new Point((this.point1.x + this.point2.x) / 2, (this.point1.y + this.point2.y) / 2);\r\n    }\r\n    longueur = function () {\r\n        return Math.sqrt(Math.pow(this.point1.x - this.point2.x, 2) + Math.pow(this.point1.y - this.point2.y, 2));\r\n    }\r\n    angle = function () {\r\n        // Retourne l'angle orienté entre le segment et l'axe des abscisses\r\n        let vecteur = new Vecteur(this.point2.x - this.point1.x, this.point2.y - this.point1.y);\r\n        return vecteur.angle(new Vecteur(1, 0));\r\n    }\r\n}\n\n//# sourceURL=webpack://MyLibrary/./src/js/class2.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _interactif2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interactif2.js */ \"./src/js/interactif2.js\");\n\r\n\r\nvar insererEntetesBlocsLesson = function () {\r\n    // Définitions\r\n    const definitions = document.querySelectorAll('.definition');\r\n    definitions.forEach((definition, index) => {\r\n        definition.innerHTML = `\r\n        <span id=\"def${index + 1}\" class=\"header header-definition\">\r\n            Définition ${index + 1}.\r\n        </span>${definition.innerHTML}`;\r\n    });\r\n\r\n    // Exemples\r\n    const exemples = document.querySelectorAll('.exemple');\r\n    exemples.forEach((exemple, index) => {\r\n        exemple.innerHTML = `\r\n        <details class=\"detailExemple\">\r\n            <summary>\r\n                <span id=\"exemple${index + 1}\" class=\"header header-exemple\">\r\n                    Exemple ${index + 1}.\r\n                </span>\r\n            </summary>\r\n            ${exemple.innerHTML}\r\n        </details>`;\r\n    });\r\n\r\n    // Propriétés\r\n    const proprietes = document.querySelectorAll('.propriete');\r\n    proprietes.forEach((propriete, index) => {\r\n        propriete.innerHTML = `\r\n        <span id=\"prop${index + 1}\" class=\"header header-propriete\">\r\n            Propriété ${index + 1}.\r\n        </span>${propriete.innerHTML}`;\r\n    });\r\n\r\n    // Remarques\r\n    const remarques = document.querySelectorAll('.remarque');\r\n    remarques.forEach((remarque, index) => {\r\n        remarque.innerHTML = `\r\n        <span id=\"remarque${index + 1}\" class=\"header header-remarque\">\r\n            Remarque ${index + 1}.\r\n        </span>${remarque.innerHTML}`;\r\n    });\r\n\r\n    // Démonstrations\r\n    const demonstrations = document.querySelectorAll('.demonstration');\r\n    demonstrations.forEach((demo, i) => {\r\n        demo.innerHTML = `\r\n    <details class=\"detailDemonstration\">\r\n      <summary>\r\n        <span id=\"proof${i + 1}\"\r\n            class=\"header header-proof\">\r\n          Démonstration ${i + 1}.\r\n        </span>\r\n      </summary>\r\n      ${demo.innerHTML}\r\n      <span style=\"font-size: 150%;\">&#9633;</span>\r\n    </details>\r\n  `;\r\n    });\r\n};\r\nvar insererEntetesBlocsExercices = function () {\r\n    // Exercices\r\n    const exercices = document.querySelectorAll('.exercice');\r\n    exercices.forEach((exercice, index) => {\r\n        const title = document.createElement('titreExercice');\r\n        title.innerHTML = `\r\n        <span class=\"titreExercice\">\r\n            Exercice ${index + 1}\r\n        </span>`;\r\n        exercice.insertBefore(title, exercice.firstChild);\r\n    });\r\n\r\n    // Exercices sans calculatrice\r\n    var exercicesSansCalculatrice = document.querySelectorAll('.exercice:not(.calculator)');\r\n    for (var i = 0; i < exercicesSansCalculatrice.length; i++) {\r\n        exercicesSansCalculatrice[i].querySelector('.titreExercice').innerHTML += ' <span class=\"fa-stack fa-lg\" style=\"font-size: 18px;\"><i class=\"fas fa-calculator fa-stack-1x\"></i><i class=\"fas fa-ban fa-stack-2x\" style=\"color:Tomato\"></i></span>';\r\n    }\r\n\r\n    // Solutions\r\n    var solutions = document.querySelectorAll('.solution');\r\n    for (var i = 0; i < solutions.length; i++) {\r\n        var details = document.createElement('details');\r\n        //details.setAttribute('open', '');\r\n        details.classList.add('solution');\r\n        details.innerHTML = '<summary>Solution</summary>';\r\n        solutions[i].parentNode.insertBefore(details, solutions[i]);\r\n        details.appendChild(solutions[i]);\r\n    }\r\n\r\n    // Indice\r\n    var indices = document.querySelectorAll('.indice');\r\n    for (var i = 0; i < indices.length; i++) {\r\n        var details = document.createElement('details');\r\n        //details.setAttribute('open', '');\r\n        details.classList.add('indice');\r\n        details.innerHTML = '<summary>Indice</summary>';\r\n        indices[i].parentNode.insertBefore(details, indices[i]);\r\n        details.appendChild(indices[i]);\r\n    }\r\n};\r\nvar wrapElementsInReveal = function (parent) {\r\n    var elements = parent.querySelectorAll('li, p, td,.katex-display');\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n        var reveal = document.createElement('div');\r\n        reveal.className = 'reveal';\r\n        reveal.innerHTML = elements[i].innerHTML;\r\n        elements[i].innerHTML = '';\r\n        elements[i].appendChild(reveal);\r\n        reveal.addEventListener('click', function () {\r\n            this.classList.add('clicked');\r\n        });\r\n\r\n        wrapElementsInReveal(reveal);\r\n    }\r\n}\r\nvar masquerSolutionsExercices = function () {\r\n    var solutions = document.querySelectorAll('details.solution .solution');\r\n    solutions.forEach(function (solution) {\r\n        wrapElementsInReveal(solution);\r\n    });\r\n}\r\nvar insererFigures = function () {\r\n    // Tester si le document contient des éléments de la class figure\r\n    if (document.querySelector(\".figure\") != null) {\r\n        // Recupérer le nom du fichier\r\n        var filename = window.location.pathname.split(\"/\").pop();\r\n        // Modifier son extension en svg\r\n        filename = filename.replace(/\\.[^/.]+$/, \".svg\");\r\n        // Charger le fichier svg et le script d'interactivité si nécessaire\r\n        d3.text(filename).then(function (svgData) {\r\n            var parser = new DOMParser();\r\n            var doc = parser.parseFromString(svgData, \"image/svg+xml\");\r\n            // Rechercher dans le document toutes les balises de class figure\r\n            var figures = document.querySelectorAll(\".figure\");\r\n            // Pour chaque figure, on récupère son id et on va chercher la figure dans doc\r\n            figures.forEach(function (figure) {\r\n                var id = figure.id;\r\n                var svg = doc.getElementById(id);\r\n                // On essaie de voir s'il a trouvé la figure. Si oui, on l'ajoute dans la div de class figure, sinon on affiche un message d'erreur\r\n                // Si la figure est déjà présente dans le document, on ne fait rien\r\n                if (figure.querySelector(\"svg\") == null) {\r\n                    if (svg == null) {\r\n                        // On affiche en bleu le message d'erreur\r\n                        figure.style.color = \"blue\";\r\n                        // Le message est barré\r\n                        figure.style.textDecoration = \"line-through\";\r\n                        figure.innerHTML = \"<i>Erreur : La figure \" + id + \" n'a pas été trouvée</i>\";\r\n                    } else {\r\n                        figure.appendChild(svg);\r\n                    }\r\n                }\r\n            })\r\n            ;(0,_interactif2_js__WEBPACK_IMPORTED_MODULE_0__.createFigures)();\r\n        });\r\n    }\r\n}\r\nvar convertirKatexEnMathML = function () {\r\n    renderMathInElement(document.body, {\r\n        // customised options\r\n        // • auto-render specific keys, e.g.:\r\n        delimiters: [\r\n            { left: '$$', right: '$$', display: true },\r\n            { left: '$', right: '$', display: false },\r\n            { left: '\\\\(', right: '\\\\)', display: false },\r\n            { left: '\\\\[', right: '\\\\]', display: true }\r\n        ],\r\n        // • rendering keys, e.g.:\r\n        throwOnError: false,\r\n        ignoredTags: [\"svg\"],\r\n        output: \"html\", // Compatibilité avec Apple notamment\r\n    });\r\n}\r\nvar ajouterSommaire = function () {\r\n    if (document.querySelector(\"#tableOfContents\") != null) {\r\n        var toc = document.getElementById('tableOfContents');\r\n        var headers = document.querySelectorAll('h2, h3');\r\n\r\n        headers.forEach(function (header, index) {\r\n            var id = 'title' + index;\r\n            header.id = id;\r\n\r\n            var link = document.createElement('a');\r\n            link.href = '#' + id;\r\n            link.textContent = header.textContent;\r\n            toc.appendChild(link);\r\n            toc.appendChild(document.createElement('br'));\r\n        });\r\n    }\r\n}\r\nvar openAvantPrint = function () {\r\n    window.onbeforeprint = function () {\r\n        const detailsElements = document.querySelectorAll('details');\r\n        detailsElements.forEach(details => {\r\n            details.setAttribute('open', '');\r\n        });\r\n    }\r\n}\r\ndocument.addEventListener(\"DOMContentLoaded\", function () {\r\n    insererEntetesBlocsLesson();\r\n    insererEntetesBlocsExercices();\r\n    insererFigures();\r\n    convertirKatexEnMathML();\r\n    masquerSolutionsExercices();\r\n    ajouterSommaire();\r\n    openAvantPrint();\r\n});\n\n//# sourceURL=webpack://MyLibrary/./src/js/index.js?");

/***/ }),

/***/ "./src/js/interactif2.js":
/*!*******************************!*\
  !*** ./src/js/interactif2.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFigures: () => (/* binding */ createFigures)\n/* harmony export */ });\n/* harmony import */ var _class2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./class2.js */ \"./src/js/class2.js\");\n// Version: 1.0.0\r\n\r\n///////////////////////\r\n////// Remarques //////\r\n///////////////////////\r\n// L'attribut \"name\" ne doit pas comporter de tiret - (voir automaticHideCrossPoint)). Faut-il ajouter un attribut figureId pour identifier les points autrement ?\r\n// La class \"selectionne\" est utilisée pour afficher ou non le disque de surlignage (est-ce une bonne solution ?) : \"unselected\" et \"selected\" peuvent-elle remplacer cette classe (fonctionnement différent) ?\r\n// On reconnait un point draggable par le fait qu'il possède un petit cercle sélectionnerur (class=\"selectionneur\")\r\n// Les points liés sont ceux qui ont un attribu linkto qui contient l'id du point déplacé\r\n// Les attributs x et y initialisent les coordonnées du point\r\n// Les coordonnées x et y sont données par l'attribut transform=\"translate(x,y)\"\r\n// Est-il possible que si on déplace un point dont un point est lié avec un rapport k, ce rapport ne change pas si on le déplace ?\r\n\r\n\r\n// Liste des codages possibles\r\nvar codagesSegment = [\r\n    \"M-5,-5 L0,5 M0,-5 L5,5\",\r\n    \"M-2.5,-5 L2.5,5\",\r\n    \"M-5,-5 L-1,5 M-1,-5 L3,5 M3,-5 L7,5\",\r\n    \"M-5,-5 L-2,5 M-2,-5 L1,5 M1,-5 L4,5 M4,-5 L7,5\"\r\n]\r\n\r\nvar setUniqueIds = function () {\r\n    // On récupère toutes les balises de class figure\r\n    var figures = document.querySelectorAll(\".figure\");\r\n    // On rend unique les identifiants des éléments constitutifs de la figure\r\n    for (var i = 0; i < figures.length; i++) {\r\n        // On récupère l'identifiant de la figure\r\n        var id = figures[i].id;\r\n        // on teste si la figure contient un svg\r\n        if (figures[i].querySelector(\"svg\") != null) {\r\n            var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*[name]\");\r\n            // Pour chaque identifiant\r\n            for (var j = 0; j < ids.length; j++) {\r\n                // On créé un id pour l'élément\r\n                ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"name\"));\r\n\r\n                // On ajoute également l'identifiant à tous les éléments du linkto\r\n                if (ids[j].getAttribute(\"linkto\") != null) {\r\n                    var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\r\n                    for (var k = 0; k < linkto.length; k++) {\r\n                        linkto[k] = id + \"-\" + linkto[k];\r\n                    }\r\n                    ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\r\n                }\r\n            }\r\n            // On sélectionne maintenant tous qui n'ont pas la class name\r\n            var ids = figures[i].querySelector(\"svg\").querySelectorAll(\"*:not([name])\");\r\n            // On ajoute un identifiant s'ils n'ont pas de linkto\r\n            for (var j = 0; j < ids.length; j++) {\r\n                if (ids[j].getAttribute(\"linkto\") == null) {\r\n                    ids[j].setAttribute(\"id\", id + \"-\" + j);\r\n                } else {\r\n                    // On créé un id pour l'élément à partir du linkto\r\n                    ids[j].setAttribute(\"id\", id + \"-\" + ids[j].getAttribute(\"linkto\"));\r\n                }\r\n                // On ajoute également l'identifiant à tous les éléments du linkto\r\n                if (ids[j].getAttribute(\"linkto\") != null) {\r\n                    var linkto = ids[j].getAttribute(\"linkto\").split(\" \");\r\n                    for (var k = 0; k < linkto.length; k++) {\r\n                        linkto[k] = id + \"-\" + linkto[k];\r\n                    }\r\n                    ids[j].setAttribute(\"linkto\", linkto.join(\" \"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nvar addBoutonQuadrillage = function (figure) {\r\n    // On ajoute un bouton pour afficher/masquer le quadrillage\r\n    var bouton = document.createElement(\"button\");\r\n    bouton.innerHTML = \"Afficher/masquer le quadrillage\";\r\n    var quadrillage = figure.querySelector(\"#\" + figure.id + \"-quadrillage\");\r\n    bouton.addEventListener(\"click\", function () {\r\n        if (quadrillage.style.display == \"none\") {\r\n            quadrillage.style.display = \"block\";\r\n        } else {\r\n            quadrillage.style.display = \"none\";\r\n        }\r\n    });\r\n    figure.appendChild(bouton);\r\n}\r\nvar addBoutonPleinEcran = function (figure) {\r\n    // On ajoute un bouton pour afficher/masquer le quadrillage\r\n    var bouton = document.createElement(\"button\");\r\n    bouton.innerHTML = \"Plein écran\";\r\n    bouton.addEventListener(\"click\", function () {\r\n        if (!document.fullscreenElement) {\r\n            if (figure.requestFullscreen) {\r\n                figure.requestFullscreen();\r\n            } else if (figure.webkitRequestFullscreen) { /* Safari */\r\n                figure.webkitRequestFullscreen();\r\n            } else if (figure.msRequestFullscreen) { /* IE11 */\r\n                figure.msRequestFullscreen();\r\n            }\r\n        } else {\r\n            if (document.exitFullscreen) {\r\n                document.exitFullscreen();\r\n            } else if (document.webkitExitFullscreen) { /* Safari */\r\n                document.webkitExitFullScreen();\r\n            } else if (document.msExitFullscreen) { /* IE11 */\r\n                document.msExitFullScreen();\r\n            }\r\n        }\r\n    });\r\n    figure.appendChild(bouton);\r\n}\r\nvar addQuadrillage = function (figure) {\r\n    // On ajoute un quadrillage\r\n    var quadrillage = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n    quadrillage.setAttribute(\"id\", \"quadrillage\");\r\n    // On récupère les dimensions de la figure avec viewBox\r\n    var viewBox = figure.querySelector(\"svg\").getAttribute(\"viewBox\").split(\" \");\r\n    var width = parseFloat(viewBox[2]);\r\n    var height = parseFloat(viewBox[3]);\r\n    var xmin = parseFloat(viewBox[0]);\r\n    var ymin = parseFloat(viewBox[1]);\r\n    // On calcule le nombres de lignes et de colonnes\r\n    var nblignes = Math.floor(height / 10);\r\n    var nbcolonnes = Math.floor(width / 10);\r\n    // On ajoute les lignes verticales\r\n    for (i = 0; i < nbcolonnes+1; i++) {\r\n        var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n        ligne.setAttribute(\"x1\", xmin + i * 10);\r\n        ligne.setAttribute(\"y1\", ymin);\r\n        ligne.setAttribute(\"x2\", xmin + i * 10);\r\n        ligne.setAttribute(\"y2\", ymin + height);\r\n        ligne.setAttribute(\"stroke\", \"gray\");\r\n        ligne.setAttribute(\"stroke-width\", \"0.2\");\r\n        quadrillage.appendChild(ligne);\r\n    }\r\n    // On ajoute les lignes horizontales\r\n    for (var i = 0; i < nblignes+1; i++) {\r\n        var ligne = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n        ligne.setAttribute(\"x1\", xmin);\r\n        ligne.setAttribute(\"y1\", ymin + i * 10);\r\n        ligne.setAttribute(\"x2\", xmin + width);\r\n        ligne.setAttribute(\"y2\", ymin + i * 10);\r\n        ligne.setAttribute(\"stroke\", \"gray\");\r\n        ligne.setAttribute(\"stroke-width\", \"0.2\");\r\n        quadrillage.appendChild(ligne);\r\n    }\r\n    if (!figure.querySelector(\"svg\").classList.contains(\"quadrillage\")) {\r\n        quadrillage.style.display = \"none\";\r\n    }\r\n    quadrillage.style.userSelect = \"none\";\r\n    quadrillage.style.pointerEvents = \"none\";\r\n    quadrillage.id = figure.id + \"-quadrillage\";\r\n    figure.querySelector(\"svg\").prepend(quadrillage);\r\n}\r\nvar getLinkto = function (objet) {\r\n    return objet.getAttribute(\"linkto\").split(\" \");\r\n}\r\nvar getElementLinkto = function (objet, n) {\r\n    return document.getElementById(getLinkto(objet)[n]);\r\n}\r\nvar constructLabelPoint = function (point) {\r\n    if (point.classList.contains(\"labeled\")) {\r\n        var idfigure = point.id.split(\"-\")[0];\r\n        var labels = document.getElementById(idfigure).querySelectorAll(\"g.label\");\r\n        var labelLinkto = Array.from(labels).filter(\r\n            label => label.getAttribute(\"linkto\") == point.id\r\n        );\r\n        var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\r\n        if (labelLinkto.length == 0) {\r\n            foreignObject.setAttribute(\"x\", \"0\");\r\n            foreignObject.setAttribute(\"y\", \"0\");\r\n            foreignObject.setAttribute(\"text-anchor\", \"start\");\r\n            foreignObject.setAttribute(\"width\", \"20\");\r\n            foreignObject.setAttribute(\"height\", \"20\");\r\n            foreignObject.innerHTML = katex.renderToString(point.getAttribute(\"name\"), { output: \"mathml\" });\r\n        } else {\r\n            var label = labelLinkto[0];\r\n            if (label.hasAttribute(\"x\")) {\r\n                foreignObject.setAttribute(\"x\", label.getAttribute(\"x\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"x\", \"0\");\r\n            }\r\n            if (label.hasAttribute(\"y\")) {\r\n                foreignObject.setAttribute(\"y\", label.getAttribute(\"y\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"y\", \"0\");\r\n            }\r\n            if (label.hasAttribute(\"width\")) {\r\n                foreignObject.setAttribute(\"width\", label.getAttribute(\"width\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"width\", \"20\");\r\n            }\r\n            if (label.hasAttribute(\"height\")) {\r\n                foreignObject.setAttribute(\"height\", label.getAttribute(\"height\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"height\", \"20\");\r\n            }\r\n            if (label.hasAttribute(\"text-anchor\")) {\r\n                foreignObject.setAttribute(\"text-anchor\", label.getAttribute(\"text-anchor\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"text-anchor\", \"middle\");\r\n            }\r\n            if (label.hasAttribute(\"fill\")) {\r\n                foreignObject.setAttribute(\"fill\", label.getAttribute(\"fill\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"fill\", \"black\");\r\n            }\r\n            if (label.hasAttribute(\"stroke\")) {\r\n                foreignObject.setAttribute(\"stroke\", label.getAttribute(\"stroke\"));\r\n            } else {\r\n                foreignObject.setAttribute(\"stroke\", \"stroke\");\r\n            }\r\n            foreignObject.setAttribute(\"style\", labelLinkto[0].getAttribute(\"style\"));\r\n            foreignObject.innerHTML = katex.renderToString(label.innerHTML, { output: \"mathml\" });\r\n        }\r\n        foreignObject.style.userSelect = \"none\";\r\n        point.appendChild(foreignObject);\r\n    }\r\n}\r\nvar constructCrossPoint = function (point) {\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"d\", \"M-2,-2 L2,2 M-2,2 L2,-2\");\r\n    path.setAttribute(\"fill\", \"transparent\");\r\n    path.setAttribute(\"stroke\", \"black\");\r\n    path.setAttribute(\"class\", \"crosspoint\");\r\n    path.style.userSelect = \"none\";\r\n    // Récupérer le style du point\r\n    var style = point.getAttribute(\"style\");\r\n    path.setAttribute(\"style\", style);\r\n    point.appendChild(path);\r\n}\r\nvar automaticHideCrossPoint = function (point) {\r\n    var idfigure = point.id.split(\"-\")[0];\r\n    getPolygonesFigure(idfigure).forEach(function (polygone) {\r\n        var linkto = getLinkto(polygone);\r\n        if (linkto.includes(point.id)) {\r\n            point.querySelector(\"path.crosspoint\").setAttribute(\"stroke\", \"transparent\");\r\n        }\r\n    });\r\n}\r\nvar constructHightlightPoint = function (point) {\r\n    if (point.classList.contains(\"draggable\")) {\r\n        var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\r\n        circle.setAttribute(\"class\", \"selectionne\");\r\n        circle.setAttribute(\"cx\", \"0\");\r\n        circle.setAttribute(\"cy\", \"0\");\r\n        circle.setAttribute(\"fill\", \"transparent\");\r\n        circle.setAttribute(\"stroke\", \"transparent\");\r\n        circle.setAttribute(\"fill-opacity\", \"0.2\");\r\n        circle.setAttribute(\"r\", \"20\");\r\n        circle.style.userSelect = \"none\";\r\n        point.appendChild(circle);\r\n    }\r\n}\r\nvar constructSelectPoint = function (point) {\r\n    if (point.classList.contains(\"draggable\")) {\r\n        var circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\r\n        circle.setAttribute(\"class\", \"selectionneur\");\r\n        circle.setAttribute(\"cx\", \"0\");\r\n        circle.setAttribute(\"cy\", \"0\");\r\n        circle.setAttribute(\"fill\", \"transparent\");\r\n        circle.setAttribute(\"r\", \"4\");\r\n        point.appendChild(circle);\r\n    }\r\n}\r\nvar getPointsFigure = function (figure) {\r\n    var points = document.querySelectorAll(\"g.point\");\r\n    var pointsArray = Array.from(points);\r\n    return pointsArray.filter(\r\n        point => point.id.split(\"-\")[0] == figure.id\r\n    );\r\n}\r\nvar initialiserPointTransform = function (point) {\r\n    var x = 0\r\n    var y = 0\r\n    if (point.hasAttribute(\"x\")) {\r\n        x = point.getAttribute(\"x\");\r\n    }\r\n    if (point.hasAttribute(\"y\")) {\r\n        y = point.getAttribute(\"y\");\r\n    }\r\n    point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\r\n}\r\nvar getPolygonesFigure = function (idfigure) {\r\n    var polygones = document.querySelectorAll(\"g.polygone\");\r\n    var polygonesArray = Array.from(polygones);\r\n    return polygonesArray.filter(\r\n        polygone => polygone.id.split(\"-\")[0] == idfigure\r\n    );\r\n}\r\nvar getVecteursFigure = function (figure) {\r\n    var vecteurs = document.querySelectorAll(\"g.vecteur\");\r\n    var vecteursArray = Array.from(vecteurs);\r\n    return vecteursArray.filter(\r\n        vecteur => vecteur.id.split(\"-\")[0] == figure.id\r\n    );\r\n}\r\nvar constructHeadVecteur = function (vecteur) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n    var alpha = AB.angle() / Math.PI * 180;\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"d\", \"M-7,-2 L-0,-0 L-7,2\");\r\n    // Déterminer les coordonnées relatives de B par rappport à A\r\n    path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\r\n    path.setAttribute(\"fill\", \"black\");\r\n    path.setAttribute(\"stroke-width\", \"0.5\");\r\n    path.classList.add(\"headVecteur\");\r\n    setStroke(vecteur, path);\r\n    vecteur.appendChild(path);\r\n}\r\nvar constructLabelVecteur = function (vecteur) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n    var I = AB.milieu();\r\n    var foreignObject = document.createElementNS(\"http://www.w3.org/2000/svg\", \"foreignObject\");\r\n    foreignObject.setAttribute(\"x\", I.x);\r\n    foreignObject.setAttribute(\"y\", I.y);\r\n    foreignObject.setAttribute(\"width\", \"20\");\r\n    foreignObject.setAttribute(\"height\", \"20\");\r\n    foreignObject.setAttribute(\"style\", vecteur.getAttribute(\"style\"));\r\n    foreignObject.innerHTML = katex.renderToString(\"\\\\overrightarrow{\" + vecteur.getAttribute(\"name\") + \"}\", { output: \"mathml\" });\r\n    foreignObject.style.userSelect = \"none\";\r\n    vecteur.appendChild(foreignObject);\r\n}\r\n\r\nvar constructVecteur = function (vecteur) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\r\n    setStroke(vecteur, path);\r\n    vecteur.appendChild(path);\r\n    constructHeadVecteur(vecteur);\r\n    if (vecteur.classList.contains(\"labeled\")) {\r\n        constructLabelVecteur(vecteur);\r\n    }\r\n}\r\nvar initialiserVecteur = function (vecteur) {\r\n    constructVecteur(vecteur);\r\n}\r\nvar initialiserVecteursFigure = function (figure) {\r\n    getVecteursFigure(figure).forEach(function (vecteur) {\r\n        initialiserVecteur(vecteur);\r\n    });\r\n}\r\nvar getDroitesFigure = function (figure) {\r\n    var droites = document.querySelectorAll(\"g.droite\");\r\n    var droitesArray = Array.from(droites);\r\n    return droitesArray.filter(\r\n        droite => droite.id.split(\"-\")[0] == figure.id\r\n    );\r\n}\r\nvar determinerExtremitesDroite = function (droite) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(droite, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n    AB.setCoordonneesVecteur2Points(A, B);\r\n    var u = AB.normalisation();\r\n    var E1 = A.translation(u.multiplicationVecteur(-200));\r\n    var E2 = A.translation(u.multiplicationVecteur(200));\r\n    return [E1, E2];\r\n}\r\nvar setStroke = function (objet, path) {\r\n    var stroke = objet.hasAttribute(\"stroke\") ? objet.getAttribute(\"stroke\") : \"black\";\r\n    path.setAttribute(\"stroke\", stroke);\r\n    var strokewidth = objet.hasAttribute(\"stroke-width\") ? objet.getAttribute(\"stroke-width\") : \"0.5\";\r\n    path.setAttribute(\"stroke-width\", strokewidth);\r\n    // Si c'est un vecteur il faut que le fill soit le même que le srtoke du vecteur\r\n    if (objet.classList.contains(\"vecteur\")) {\r\n        path.setAttribute(\"fill\", stroke);\r\n    }\r\n}\r\nvar constructDroite = function (droite) {\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    var extremites = determinerExtremitesDroite(droite);\r\n    var E1 = extremites[0];\r\n    var E2 = extremites[1];\r\n    path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\r\n    setStroke(droite, path);\r\n    droite.appendChild(path);\r\n}\r\nvar initialiserDroite = function (droite) {\r\n    constructDroite(droite);\r\n}\r\nvar initialiserDroitesFigure = function (figure) {\r\n    getDroitesFigure(figure).forEach(function (droite) {\r\n        initialiserDroite(droite);\r\n    });\r\n}\r\nvar getDemidroitesFigure = function (figure) {\r\n    var demidroites = document.querySelectorAll(\"g.demidroite\");\r\n    var demidroitesArray = Array.from(demidroites);\r\n    return demidroitesArray.filter(\r\n        demidroite => demidroite.id.split(\"-\")[0] == figure.id\r\n    );\r\n}\r\nvar constructDemiDroite = function (demidroite) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(demidroite, 0)));\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    var extremites = determinerExtremitesDroite(demidroite);\r\n    var E = extremites[1];\r\n    path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + E.x + \",\" + E.y);\r\n    setStroke(demidroite, path);\r\n    demidroite.appendChild(path);\r\n}\r\nvar initialiserDemiDroite = function (demidroite) {\r\n    constructDemiDroite(demidroite);\r\n}\r\nvar initialiserDemiDroitesFigure = function (figure) {\r\n    getDemidroitesFigure(figure).forEach(function (demidroite) {\r\n        initialiserDemiDroite(demidroite);\r\n    });\r\n}\r\nvar getSegmentsFigure = function (figure) {\r\n    var segments = document.querySelectorAll(\"g.segment\");\r\n    var segmentsArray = Array.from(segments);\r\n    return segmentsArray.filter(\r\n        segment => segment.id.split(\"-\")[0] == figure.id\r\n    );\r\n}\r\nvar constructCodageSegment = function (segment, codage) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n    var I = AB.milieu();\r\n    var alpha = AB.angle() / Math.PI * 180;\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    path.setAttribute(\"fill\", \"transparent\");\r\n    path.setAttribute(\"stroke\", \"black\");\r\n    path.setAttribute(\"stroke-width\", \"0.8\");\r\n    path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + alpha + \")\");\r\n    path.setAttribute(\"d\", codage);\r\n    path.style.userSelect = \"none\";\r\n    path.classList.add(\"codageSegment\");\r\n    segment.appendChild(path);\r\n}\r\nvar isCodageSegment = function (segment) {\r\n    return segment.classList.contains(\"codage\");\r\n}\r\nvar isSegmentLie = function (segment) {\r\n    // Dans linkto, on a l'id des deux points et éventuellement l'id d'un segment lié par le codage\r\n    var linkto = getLinkto(segment);\r\n    return linkto.length == 3;\r\n}\r\nvar getSegmentLie = function (segment) {\r\n    var linkto = getLinkto(segment);\r\n    return document.getElementById(linkto[2]);\r\n}\r\nvar getCodageSegmentLie = function (segment) {\r\n    var linkto = getLinkto(segment);\r\n    return getSegmentLie(segment).querySelector(\"path.codageSegment\").getAttribute(\"d\");\r\n}\r\nvar listeCodagesFigure = function (objet) {\r\n    var idfigure = objet.id.split(\"-\")[0];\r\n    var codages = document.querySelectorAll(\"g.codage\");\r\n    var codagesArray = Array.from(codages);\r\n    var codagesFigure = codagesArray.filter(\r\n        codage => codage.id.split(\"-\")[0] == idfigure\r\n    ).filter(\r\n        codage => codage.querySelector(\"path.codageSegment\") != null\r\n    ).map(\r\n        // On récupère l'attribut d\r\n        codage => codage.querySelector(\"path.codageSegment\").getAttribute(\"d\")\r\n    );\r\n    return codagesFigure;\r\n}\r\nvar nouveauCodageSegment = function (segment) {\r\n    var codageExistants = listeCodagesFigure(segment);\r\n    // On veut un codage qui n'existe pas déjà\r\n    var i = 0;\r\n    while (codageExistants.includes(codagesSegment[i])) {\r\n        i++;\r\n        if (i == codagesSegment.length) {\r\n            break;\r\n        }\r\n    }\r\n    if (i < codagesSegment.length) {\r\n        return codagesSegment[i];\r\n    } else {\r\n        // Plus de codages disponibles\r\n        return \"\"\r\n    }\r\n}\r\nvar constructSegment = function (segment) {\r\n    var A = getElementLinkto(segment, 0);\r\n    var B = getElementLinkto(segment, 1);\r\n    // Construire un élément path\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    // A est l'origine et B l'extrémité du path\r\n    path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\r\n    setStroke(segment, path);\r\n    segment.appendChild(path);\r\n    if (isCodageSegment(segment)) {\r\n        if (isSegmentLie(segment)) {\r\n            constructCodageSegment(segment, getCodageSegmentLie(segment));\r\n        } else {\r\n            constructCodageSegment(segment, nouveauCodageSegment(segment));\r\n        }\r\n    }\r\n}\r\nvar initialiserSegment = function (segment) {\r\n    constructSegment(segment);\r\n}\r\nvar initialiserSegmentsFigure = function (figure) {\r\n    getSegmentsFigure(figure).forEach(function (segment) {\r\n        initialiserSegment(segment);\r\n    });\r\n}\r\nvar constructPolygone = function (polygone) {\r\n    var points = getLinkto(polygone).map(\r\n        point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))\r\n    ).map(point => [point.x, point.y].join(','));\r\n    var path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\r\n    var d = \"M\" + points.join(\" L\") + \" Z\";\r\n    path.setAttribute(\"d\", d);\r\n    setStroke(polygone, path);\r\n    polygone.appendChild(path);\r\n}\r\nvar initialiserPolygone = function (polygone) {\r\n    constructPolygone(polygone);\r\n}\r\nvar initialiserPolygonesFigure = function (figure) {\r\n    getPolygonesFigure(figure.id).forEach(function (polygone) {\r\n        initialiserPolygone(polygone);\r\n    });\r\n}\r\nvar initialiserFigure = function (figure) {\r\n    addQuadrillage(figure);\r\n    addBoutonQuadrillage(figure);\r\n    addBoutonPleinEcran(figure);\r\n    initialiserPointsFigure(figure);\r\n    initialiserVecteursFigure(figure);\r\n    initialiserDroitesFigure(figure);\r\n    initialiserDemiDroitesFigure(figure);\r\n    initialiserSegmentsFigure(figure);\r\n    initialiserPolygonesFigure(figure);\r\n}\r\nvar getCoordonneesPoint = function (point) {\r\n    var data = point.getAttribute(\"transform\").split(\"translate(\")[1].split(\")\")[0].split(\",\");\r\n    var x = parseFloat(data[0]);\r\n    var y = parseFloat(data[1]);\r\n    return [x, y];\r\n}\r\nvar setCoordonneesPoint = function (point, x, y) {\r\n    point.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");\r\n}\r\nvar actualiserCoordonneesPointClassTranslation = function (point) {\r\n    if (point.classList.contains(\"translation\")) {\r\n        // M est l'image de P par la translation de vecteur kAB\r\n        var A = getElementLinkto(point, 0)\r\n        var B = getElementLinkto(point, 1)\r\n        var P = getElementLinkto(point, 2)\r\n        let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\r\n        let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\r\n        let u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n        u.setCoordonneesVecteur2Points(P1, P2);\r\n        let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\r\n        var data = point.getAttribute(\"data\").split(\" \");\r\n        var k = parseFloat(data[0]);\r\n        let P4 = P3.translation(u.multiplicationVecteur(k));\r\n        var x4 = P4.x;\r\n        var y4 = P4.y;\r\n        setCoordonneesPoint(point, x4, y4);\r\n    }\r\n}\r\nvar actualiserCoordonneesPointClassDilatation = function (point) {\r\n    if (point.classList.contains(\"dilatation\")) {\r\n        // H est le projeté de P selon la direction formant un angle alpha avec le vecteur AB\r\n        // M est l'image de P par l'homothétie de rapport k et de centre H \r\n        var A = getElementLinkto(point, 0)\r\n        var B = getElementLinkto(point, 1)\r\n        var P = getElementLinkto(point, 2)\r\n        let P1 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(A));\r\n        let P2 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(B));\r\n        let P3 = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(P));\r\n        var data = point.getAttribute(\"data\").split(\" \");\r\n        var k = parseFloat(data[1]);\r\n        var alpha = parseFloat(data[0]) / 180 * Math.PI;\r\n        var H = P3.projectionAngle(P1, P2, alpha);\r\n        var M = P3.homothetie(H, k)\r\n        setCoordonneesPoint(point, M.x, M.y)\r\n    }\r\n}\r\nvar actualiserCoordonneesPointClassRotation = function (point) {\r\n    if (point.classList.contains(\"rotation\")) {\r\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n        var data = point.getAttribute(\"data\").split(\" \");\r\n        var alpha = parseFloat(data[0]) / 180 * Math.PI;\r\n        if (getLinkto(point).length == 1) {\r\n            var k = parseFloat(data[1]);\r\n            var P = A.translation(new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0));\r\n            var M = P.rotation(A, alpha).homothetie(A, k);\r\n        } else if (getLinkto(point).length == 2) {\r\n            var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n            var k = parseFloat(data[1]);\r\n            var M = P.rotation(A, alpha).homothetie(A, k);\r\n        } else if (getLinkto(point).length == 3) {\r\n            var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n            var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\r\n            var k = parseFloat(data[1]);\r\n            var N = P.rotation(A, alpha).homothetie(A, k);\r\n            var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n            u.setCoordonneesVecteur2Points(A, Q);\r\n            M = N.translation(u);\r\n        }\r\n        setCoordonneesPoint(point, M.x, M.y)\r\n    }\r\n}\r\nvar actualiserCoordonneesPointsLies = function (point) {\r\n    // Récursivité pour atteindre tous les points liés\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var points = document.querySelectorAll(\"g.point[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < points.length; i++) {\r\n        actualiserCoordonneesPoint(points[i]);\r\n    }\r\n}\r\nvar initialiserDataPoint = function (point) {\r\n    // Si le point subit une tranformation, on initialise l'attribut data si ce n'est pas déjà fait\r\n    if (point.hasAttribute(\"data\") == false) {\r\n        if (point.classList.contains(\"translation\")) {\r\n            point.setAttribute(\"data\", \"1\");\r\n            point.classList.add(\"transformation\");\r\n        } else if (point.classList.contains(\"dilatation\")) {\r\n            point.setAttribute(\"data\", \"90 -1\");\r\n            point.classList.add(\"transformation\");\r\n        } else if (point.classList.contains(\"rotation\")) {\r\n            point.setAttribute(\"data\", \"90 1\");\r\n            point.classList.add(\"transformation\");\r\n        }\r\n    } else {\r\n        point.classList.add(\"transformation\");\r\n    }\r\n}\r\nvar actualiserLabelVecteur = function (vecteur) {\r\n    if (vecteur.classList.contains(\"labeled\")) {\r\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n        var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n        var I = AB.milieu();\r\n        var foreignObject = vecteur.querySelector(\"foreignObject\");\r\n        foreignObject.setAttribute(\"x\", I.x);\r\n        foreignObject.setAttribute(\"y\", I.y);\r\n    }\r\n}\r\nvar actualiserVecteur = function (vecteur) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n    var path = vecteur.querySelector(\"path\");\r\n    path.setAttribute(\"d\", \"M\" + A.x + \",\" + A.y + \" L\" + B.x + \",\" + B.y);\r\n    actualiserHeadVecteur(vecteur);\r\n    actualiserLabelVecteur(vecteur);\r\n}\r\nvar actualiserCoordonneesVecteursLies = function (point) {\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var vecteurs = document.querySelectorAll(\"g.vecteur[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < vecteurs.length; i++) {\r\n        actualiserVecteur(vecteurs[i]);\r\n    }\r\n}\r\nvar actualiserDroite = function (droite) {\r\n    var path = droite.querySelector(\"path\");\r\n    var extremites = determinerExtremitesDroite(droite);\r\n    var E1 = extremites[0];\r\n    var E2 = extremites[1];\r\n    path.setAttribute(\"d\", \"M\" + E1.x + \",\" + E1.y + \" L\" + E2.x + \",\" + E2.y);\r\n}\r\nvar actualiserCoordonneesDroitesLies = function (point) {\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var droites = document.querySelectorAll(\"g.droite[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < droites.length; i++) {\r\n        actualiserDroite(droites[i]);\r\n    }\r\n}\r\nvar actualiserDemiDroite = function (demidroite) {\r\n    var path = demidroite.querySelector(\"path\");\r\n    var extremites = determinerExtremitesDroite(demidroite);\r\n    var E = extremites[1];\r\n    var A = getElementLinkto(demidroite, 0);\r\n    path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + E.x + \",\" + E.y);\r\n}\r\nvar actualiserCoordonneesDemiDroitesLies = function (point) {\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var demidroites = document.querySelectorAll(\"g.demidroite[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < demidroites.length; i++) {\r\n        actualiserDemiDroite(demidroites[i]);\r\n    }\r\n}\r\nvar actualiserCodageSegment = function (segment) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(segment, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n    var I = AB.milieu();\r\n    var alpha = AB.angle() / Math.PI * 180;\r\n    var path = segment.querySelector(\"path.codageSegment\");\r\n    path.setAttribute(\"transform\", \"translate(\" + I.x + \",\" + I.y + \") rotate(\" + -alpha + \")\");\r\n}\r\nvar actualiserHeadVecteur = function (vecteur) {\r\n    var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 0)));\r\n    var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(vecteur, 1)));\r\n    var AB = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Segment(A, B);\r\n    var alpha = AB.angle() / Math.PI * 180;\r\n    var path = vecteur.querySelector(\"path.headVecteur\");\r\n    path.setAttribute(\"transform\", \"translate(\" + B.x + \",\" + B.y + \") rotate(\" + -alpha + \")\");\r\n}\r\nvar actualiserSegment = function (segment) {\r\n    var A = getElementLinkto(segment, 0);\r\n    var B = getElementLinkto(segment, 1);\r\n    var path = segment.querySelector(\"path\");\r\n    path.setAttribute(\"d\", \"M\" + getCoordonneesPoint(A).join(\",\") + \" L\" + getCoordonneesPoint(B).join(\",\"));\r\n    if (isCodageSegment(segment)) {\r\n        actualiserCodageSegment(segment);\r\n    }\r\n}\r\nvar actualiserCoordonneesSegmentsLies = function (point) {\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var segments = document.querySelectorAll(\"g.segment[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < segments.length; i++) {\r\n        actualiserSegment(segments[i]);\r\n    }\r\n}\r\nvar actualiserPolygone = function (polygone) {\r\n    var points = getLinkto(polygone).map(\r\n        point => new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(document.getElementById(point)))\r\n    ).map(point => [point.x, point.y].join(','));\r\n    var path = polygone.querySelector(\"path\");\r\n    var d = \"M\" + points.join(\" L\") + \" Z\";\r\n    path.setAttribute(\"d\", d);\r\n}\r\nvar actualiserCoordonneesPolygonesLies = function (point) {\r\n    var idPoint = point.getAttribute(\"id\");\r\n    var polygones = document.querySelectorAll(\"g.polygone[linkto*='\" + idPoint + \"']\");\r\n    for (var i = 0; i < polygones.length; i++) {\r\n        actualiserPolygone(polygones[i]);\r\n    }\r\n}\r\nvar actualiserCoordonneesPoint = function (point) {\r\n    actualiserCoordonneesPointClassTranslation(point);\r\n    actualiserCoordonneesPointClassDilatation(point);\r\n    actualiserCoordonneesPointClassRotation(point);\r\n    actualiserCoordonneesPointsLies(point);\r\n    actualiserCoordonneesVecteursLies(point);\r\n    actualiserCoordonneesDroitesLies(point);\r\n    actualiserCoordonneesDemiDroitesLies(point);\r\n    actualiserCoordonneesSegmentsLies(point);\r\n    actualiserCoordonneesPolygonesLies(point);\r\n}\r\nvar actualiserPointsFigure = function (figure) {\r\n    getPointsFigure(figure).forEach(function (point) {\r\n        actualiserCoordonneesPoint(point);\r\n    });\r\n}\r\nvar setHightlightPointOn = function (point) {\r\n    d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"orange\");\r\n}\r\nvar setHightlightPointOff = function (point) {\r\n    d3.select(point).select(\"circle.selectionne\").attr(\"fill\", \"transparent\");\r\n}\r\nvar controlerCoordonneesPoint = function (point, figure) {\r\n    let x = 0\r\n    let y = 0\r\n    // Points draggable avec contrainte\r\n    if (point.classList.contains(\"translation\")) {\r\n        // On détermine le projeté orthogonal du pointeur de la souris sur la droite parallèle à (AB) et passant par P\r\n        var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n        var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n        var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\r\n        var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\r\n        var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n        u.setCoordonneesVecteur2Points(A, B);\r\n        var Q = P.translation(u);\r\n        var N = M.projectionOrthogonale(P, Q);\r\n        x = N.x;\r\n        y = N.y;\r\n        // On veut la obtenir le rapport signé de la distance PN sur la distance AB\r\n        var k = P.distance(N) / A.distance(B);\r\n        // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\r\n        var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n        v.setCoordonneesVecteur2Points(P, N);\r\n        if (u.produitScalaire(v) < 0) {\r\n            k = -k;\r\n        }\r\n        point.setAttribute(\"data\", k.toString());\r\n    } else if (point.classList.contains(\"rotation\")) {\r\n        // Tester le nombre de points liés\r\n        // Si un seul point\r\n        if (point.getAttribute(\"linkto\").split(\" \").length == 1) {\r\n            var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n            var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\r\n            var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\r\n            var d = A.distance(M);\r\n            var N = M.homothetie(A, k / d);\r\n            var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur(1, 0);\r\n            var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n            v.setCoordonneesVecteur2Points(A, N);\r\n            var alpha = u.angle(v) / Math.PI * 180;\r\n            point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\r\n            x = N.x;\r\n            y = N.y;\r\n        } else if (point.getAttribute(\"linkto\").split(\" \").length == 2) {\r\n            if (!point.classList.contains(\"rapport\")) {\r\n                var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n                var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n                var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\r\n                var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\r\n                var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n                u.setCoordonneesVecteur2Points(A, B);\r\n                var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n                v.setCoordonneesVecteur2Points(A, M);\r\n                var alpha = u.angle(v) / Math.PI * 180;\r\n                point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\r\n                var N = M.homothetie(A, k);\r\n                x = N.x;\r\n                y = N.y;\r\n            } else {\r\n                // On conserve l'angle mais on change le rapport\r\n                var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n                var B = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n                var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\r\n                var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n                u.setCoordonneesVecteur2Points(A, B);\r\n                var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n                v.setCoordonneesVecteur2Points(A, M);\r\n                // Déterminer le signe avec le produit vectoriel\r\n                var signe = u.produitVectoriel(v) / Math.abs(u.produitVectoriel(v));\r\n                // On projète M sur l'image de la droite (AB) par la rotation de centre A et d'angle alpha\r\n                var alpha = parseFloat(point.getAttribute(\"data\").split(\" \")[0]) / 180 * Math.PI;\r\n                var P1 = B.rotation(A, alpha);\r\n                var N = M.projectionOrthogonale(A, P1);\r\n                var k = signe * A.distance(N) / A.distance(B);\r\n                // On veut la obtenir la distance signée en utilisant le produit scalaire de u et v\r\n                point.setAttribute(\"data\", (alpha / Math.PI * 180).toString() + \" \" + k.toString());\r\n                x = N.x;\r\n                y = N.y;\r\n                if (isNaN(N.x)) { console.log(\"N.x\", N.x, \"N.y\", N.y); }\r\n            }\r\n        } else if (point.getAttribute(\"linkto\").split(\" \").length == 3) {\r\n            // Les points sont A, P, Q tels que AQ=AP\r\n            // Le centre de rotation est maintenant Q mais on veut que le rayon soit toujours AP\r\n            var A = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 0)));\r\n            var P = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 1)));\r\n            var Q = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(...getCoordonneesPoint(getElementLinkto(point, 2)));\r\n            var M = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Point(d3.event.x, d3.event.y);\r\n            var k = parseFloat(point.getAttribute(\"data\").split(\" \")[1]);\r\n            var u = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n            u.setCoordonneesVecteur2Points(A, P);\r\n            var v = new _class2_js__WEBPACK_IMPORTED_MODULE_0__.Vecteur();\r\n            v.setCoordonneesVecteur2Points(Q, M);\r\n            var alpha = u.angle(v) / Math.PI * 180;\r\n            point.setAttribute(\"data\", alpha.toString() + \" \" + k.toString());\r\n            var N = M.homothetie(Q, k);\r\n            x = N.x;\r\n            y = N.y;\r\n        }\r\n    } else {\r\n        // Il ne faut pas dépasser les limites du cadre\r\n        x = Math.min(Math.max(d3.event.x, 0), 200);\r\n        y = Math.min(Math.max(d3.event.y, 0), 200);\r\n        // Si le quadrillage est affiché, on déplace le point sur le quadrillage\r\n        if (figure.querySelector(\"#\" + figure.id + \"-quadrillage\").style.display == \"block\") {\r\n            x = Math.round(x / 10) * 10;\r\n            y = Math.round(y / 10) * 10;\r\n        }\r\n    }\r\n    return [x, y];\r\n}\r\nvar interactivity = function (figure) {\r\n    d3.selectAll(\"g.point.draggable\").call(d3.drag().on(\"drag\", function () {\r\n        if (d3.event.x > 0 && d3.event.x < 200 && d3.event.y > 0 && d3.event.y < 200) {\r\n            setHightlightPointOn(this);\r\n            setCoordonneesPoint(this,\r\n                ...controlerCoordonneesPoint(this, figure)\r\n            );\r\n            actualiserCoordonneesPoint(this);\r\n        }\r\n    }).on(\"end\", function () {\r\n        setHightlightPointOff(this);\r\n    }));\r\n}\r\nvar initialiserPointsFigure = function (figure) {\r\n    getPointsFigure(figure).filter(\r\n        point => point.id.split(\"-\")[0] == figure.id\r\n    ).forEach(function (point) {\r\n        initialiserPointTransform(point);\r\n        constructLabelPoint(point);\r\n        constructCrossPoint(point);\r\n        //constructHightlightPoint(point);\r\n        constructSelectPoint(point);\r\n        automaticHideCrossPoint(point);\r\n        initialiserDataPoint(point);\r\n    });\r\n}\r\nvar draggablesAuPremierPlan = function (figure) {\r\n    var svg = figure.querySelector(\"svg\");\r\n    var draggable = figure.querySelectorAll(\".draggable\");\r\n    for (var i = 0; i < draggable.length; i++) {\r\n        svg.appendChild(draggable[i]);\r\n    }\r\n}\r\n\r\n// Créer les figures\r\nvar createFigures = function () {\r\n    setUniqueIds();\r\n    var figures = document.querySelectorAll(\".figure\");\r\n    for (var i = 0; i < figures.length; i++) {\r\n        if (figures[i].querySelector(\"svg\") != null) {\r\n            initialiserFigure(figures[i]);\r\n            actualiserPointsFigure(figures[i]);\r\n            draggablesAuPremierPlan(figures[i]);\r\n            figures[i].addEventListener(\"mouseenter\", function () {\r\n                interactivity(this);\r\n            });\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://MyLibrary/./src/js/interactif2.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	MyLibrary = __webpack_exports__;
/******/ 	
/******/ })()
;